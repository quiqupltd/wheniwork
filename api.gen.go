// Package wheniwork provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package wheniwork

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	W_TokenScopes = "W_Token.Scopes"
)

// Defines values for UserRole.
const (
	N1Admin           UserRole = "1 = Admin"
	N2Manager         UserRole = "2 = Manager"
	N3EmployeeDefault UserRole = "3 = Employee (Default)"
	N4LeadUnused      UserRole = "4 = Lead (Unused)"
	N5Supervisor      UserRole = "5 = Supervisor"
)

// Defines values for UserType.
const (
	N1 UserType = 1
	N2 UserType = 2
	N3 UserType = 3
)

// Account defines model for Account.
type Account struct {
	Company  *string   `json:"company,omitempty"`
	Id       *int      `json:"id,omitempty"`
	Timezone *Timezone `json:"timezone,omitempty"`
}

// BaseScheduledBreak defines model for BaseScheduledBreak.
type BaseScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// BulkEditShiftRequest Array of shift objects to update
type BulkEditShiftRequest = []ShiftBulk

// Error defines model for Error.
type Error struct {
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
	Message *string                 `json:"message,omitempty"`
}

// Login defines model for Login.
type Login struct {
	Avatar *struct {
		Size *int    `json:"size,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"avatar,omitempty"`
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	Email     *openapi_types.Email `json:"email,omitempty"`
	FirstName *string              `json:"first_name,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	LastName  *string              `json:"last_name,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Token     *string              `json:"token,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
}

// Place defines model for Place.
type Place struct {
	Address      *string    `json:"address,omitempty"`
	BusinessName *string    `json:"business_name,omitempty"`
	Country      *string    `json:"country,omitempty"`
	Id           *int       `json:"id,omitempty"`
	Latitude     *float32   `json:"latitude,omitempty"`
	Locality     *string    `json:"locality,omitempty"`
	Longitude    *float32   `json:"longitude,omitempty"`
	PlaceId      *string    `json:"place_id,omitempty"`
	PlaceType    *[]string  `json:"place_type,omitempty"`
	PostalCode   *string    `json:"postal_code,omitempty"`
	Region       *string    `json:"region,omitempty"`
	StreetName   *string    `json:"street_name,omitempty"`
	StreetNumber *string    `json:"street_number,omitempty"`
	SubLocality  *string    `json:"sub_locality,omitempty"`
	UpdatedAt    *time.Time `json:"updated_at,omitempty"`
}

// Shift defines model for Shift.
type Shift struct {
	AccountId *int `json:"account_id,omitempty"`

	// Acknowledged If enabled; When the user confirmed the shift
	Acknowledged *bool `json:"acknowledged,omitempty"`

	// AcknowledgedAt If enabled; When the user confirmed the shift
	AcknowledgedAt *time.Time `json:"acknowledged_at,omitempty"`

	// Alerted Is the shift Alert sent
	Alerted *bool `json:"alerted,omitempty"`

	// BreakTime Length of the unpaid breaks for the shift in hours.
	BreakTime *float32 `json:"break_time,omitempty"`

	// Breaks An array of breaks for the shift. When updating a shift, any existing breaks for the shift that are not included in the request will be deleted.
	Breaks *[]ShiftScheduledBreak `json:"breaks,omitempty"`

	// Color Assign color to shift
	Color     *string    `json:"color,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatorId The user that created the shift
	CreatorId *int      `json:"creator_id,omitempty"`
	EndTime   time.Time `json:"end_time"`
	Id        *int      `json:"id,omitempty"`
	Instances *int      `json:"instances,omitempty"`

	// IsApprovedWithoutTime Used to indicate that a manager or supervisor has approved a missing time entry for this shift
	IsApprovedWithoutTime *bool `json:"is_approved_without_time,omitempty"`
	IsOpen                *bool `json:"is_open,omitempty"`

	// IsShared Is the shift a shared OpenShift
	IsShared *bool `json:"is_shared,omitempty"`

	// IsTrimmed Is rounding active for shift
	IsTrimmed *bool `json:"is_trimmed,omitempty"`

	// LinkedUsers Array of user IDs that can take this openshift. Null means all users are eligible.
	LinkedUsers *[]int `json:"linked_users,omitempty"`

	// LocationId Location the shift belongs to
	LocationId int `json:"location_id"`

	// Notes Text notation for a Shift
	Notes      *string    `json:"notes,omitempty"`
	NotifiedAt *time.Time `json:"notified_at,omitempty"`

	// OpenshiftApprovalRequestId ID of the associated OpenShift Approval request
	OpenshiftApprovalRequestId *int `json:"openshift_approval_request_id,omitempty"`
	PositionId                 *int `json:"position_id,omitempty"`

	// Published Is the shift published
	Published     *bool      `json:"published,omitempty"`
	PublishedDate *time.Time `json:"published_date,omitempty"`

	// RequiresOpenshiftApproval Does this shift require OpenShift Approval
	RequiresOpenshiftApproval *bool `json:"requires_openshift_approval,omitempty"`

	// ShiftchainKey The ID to associate shifts in a repeating pattern
	ShiftchainKey *string    `json:"shiftchain_key,omitempty"`
	SiteId        *int       `json:"site_id,omitempty"`
	StartTime     time.Time  `json:"start_time"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`

	// UserId The user assigned to the shift. Set to `0` for an Open Shift.
	UserId *int `json:"user_id,omitempty"`
}

// ShiftBulk defines model for ShiftBulk.
type ShiftBulk struct {
	AccountId *int     `json:"account_id,omitempty"`
	BreakTime *float32 `json:"break_time,omitempty"`

	// Color Assign color to shift
	Color   *string   `json:"color,omitempty"`
	EndTime time.Time `json:"end_time"`
	Id      int       `json:"id"`

	// LinkedUsers Array of user IDs that can take this openshift. Null means all users are eligible.
	LinkedUsers *[]int `json:"linked_users,omitempty"`

	// LocationId Location the shift belongs to
	LocationId int `json:"location_id"`

	// Notes Text notation for a Shift
	Notes      *string   `json:"notes,omitempty"`
	PositionId *int      `json:"position_id,omitempty"`
	SiteId     *int      `json:"site_id,omitempty"`
	StartTime  time.Time `json:"start_time"`

	// UserId The user assigned to the shift. Set to `0` for an Open Shift.
	UserId *int `json:"user_id,omitempty"`
}

// ShiftChain defines model for ShiftChain.
type ShiftChain struct {
	// Count The number of shifts created by this chain.
	// Deprecated:
	Count *int    `json:"count,omitempty"`
	Key   *string `json:"key,omitempty"`

	// Rrule The RFC5545-compliant RRule representing the shift chain.
	Rrule *string `json:"rrule,omitempty"`

	// TimezoneId The timezone this chain is built in
	TimezoneId *string `json:"timezone_id,omitempty"`

	// Until The date when the shift chain ends.
	Until *openapi_types.Date `json:"until,omitempty"`

	// Week Represents the week frequency interval. `1` means weekly, `2` means every two weeks, etc.
	Week *int `json:"week,omitempty"`

	// Weekdays A bitmask of the weekdays which shifts in this chain occur on. In a seven-bit binary number, the most
	// significant bit represents Sunday and the least significant bit represents Monday (0b1000001).
	//
	// Examples:
	// | Days                      | Binary      | Decimal |
	// |---------------------------|-------------|---------|
	// | Monday through Friday     | `0b0011111` | 31      |
	// | Monday, Wednesday, Friday | `0b0010101` | 21      |
	// | Saturday and Sunday       | `0b1100000` | 96      |
	Weekdays *int `json:"weekdays,omitempty"`
}

// ShiftScheduledBreak defines model for ShiftScheduledBreak.
type ShiftScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// EndTime The end time of the break. Null if the break does not have an end time. Calculated from the start time of the break and the length.
	EndTime *string `json:"end_time,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// ShiftId The ID of the shift that the break applies to.
	ShiftId *int `json:"shift_id,omitempty"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// StartTime The start time of the break. Null if the break does not have a start time.
	StartTime *string `json:"start_time,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// Site defines model for Site.
type Site struct {
	AccountId   *int       `json:"account_id,omitempty"`
	Address     *string    `json:"address,omitempty"`
	Color       *string    `json:"color,omitempty"`
	Coordinates *[]float32 `json:"coordinates,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *time.Time `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *int       `json:"id,omitempty"`
	IsDeleted   *bool      `json:"is_deleted,omitempty"`
	Latitude    *float32   `json:"latitude,omitempty"`
	LocationId  *int       `json:"location_id,omitempty"`
	Longitude   *float32   `json:"longitude,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Place       *Place     `json:"place,omitempty"`
	PlaceId     *string    `json:"place_id,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// SiteRequest defines model for SiteRequest.
type SiteRequest struct {
	AccountId   *int       `json:"account_id,omitempty"`
	Address     *string    `json:"address,omitempty"`
	Color       *string    `json:"color,omitempty"`
	Coordinates *[]float32 `json:"coordinates,omitempty"`
	Description *string    `json:"description,omitempty"`
	Latitude    *float32   `json:"latitude,omitempty"`
	LocationId  *int       `json:"location_id,omitempty"`
	Longitude   *float32   `json:"longitude,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Place       *Place     `json:"place,omitempty"`
	PlaceId     *string    `json:"place_id,omitempty"`
}

// Time defines model for Time.
type Time struct {
	// AccountId The account id
	AccountId *int `json:"account_id,omitempty"`

	// AlertType The type of alert for this time
	AlertType *int `json:"alert_type,omitempty"`

	// CashTips Any cash tips reported for the shift.
	// Note: the tips feature is required to see and use this field.
	CashTips *string `json:"cash_tips"`

	// CreatedAt When the time was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatorId The user that created the time.
	CreatorId *int `json:"creator_id,omitempty"`

	// EndTime The end time
	EndTime *time.Time `json:"end_time,omitempty"`

	// HourlyRate The base hourly rate for this time.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// Id The time id
	Id *int `json:"id,omitempty"`

	// IsAlerted If alert_type > 0
	IsAlerted *bool `json:"is_alerted,omitempty"`

	// IsApproved If the time is approved
	IsApproved *bool `json:"is_approved,omitempty"`

	// Length The length of the time in hours.
	Length *float32 `json:"length,omitempty"`

	// LocationId Location the time belongs to. 0 if unassigned.
	LocationId *int `json:"location_id,omitempty"`

	// ModifiedBy The user that modified the time
	ModifiedBy *int `json:"modified_by,omitempty"`

	// Notes Notes for a time
	Notes *string `json:"notes,omitempty"`

	// PositionId Position the time belongs to. 0 if unassigned.
	PositionId *int `json:"position_id,omitempty"`

	// RoundedEndTime The rounded end time. If rounding is not enabled this field will not be present.
	RoundedEndTime *time.Time `json:"rounded_end_time,omitempty"`

	// RoundedLength The rounded length calculated from the rounded_start_time and rounded_end_time. If rounding is not enabled this field will not be present.
	RoundedLength *float32 `json:"rounded_length,omitempty"`

	// RoundedStartTime The rounded start time. If rounding is not enabled this field will not be present.
	RoundedStartTime *time.Time `json:"rounded_start_time,omitempty"`

	// ShiftId A shift tied to this time. 0 if unassigned.
	ShiftId *int `json:"shift_id,omitempty"`

	// SiteId Site the time belongs to. 0 if unassigned.
	SiteId *int `json:"site_id,omitempty"`

	// SplitTime If the time crosses payroll periods, when to split it
	SplitTime *time.Time `json:"split_time,omitempty"`

	// StartTime The start time
	StartTime *time.Time `json:"start_time,omitempty"`

	// SyncHash The quickbooks sync hash
	SyncHash *string `json:"sync_hash,omitempty"`

	// SyncId The quickbooks sync id
	SyncId *string `json:"sync_id,omitempty"`

	// UpdatedAt When the time was updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserId The user assigned to the time.
	UserId *int `json:"user_id,omitempty"`
}

// TimeRequest defines model for TimeRequest.
type TimeRequest struct {
	// CashTips The amount of cash tips reported for the time entry.
	CashTips *string `json:"cash_tips,omitempty"`

	// EndTime The end time
	EndTime *time.Time `json:"end_time,omitempty"`

	// IsApproved If the time is approved
	IsApproved *bool `json:"is_approved,omitempty"`

	// LocationId Location the time belongs to. 0 if unassigned.
	LocationId *int `json:"location_id,omitempty"`

	// Notes Notes for a time
	Notes *string `json:"notes,omitempty"`

	// PositionId Position the time belongs to. 0 if unassigned.
	PositionId *int `json:"position_id,omitempty"`

	// RoundedEndTime The rounded end time. If rounding is not enabled this field will not be present.
	RoundedEndTime *time.Time `json:"rounded_end_time,omitempty"`

	// RoundedStartTime The rounded start time. If rounding is not enabled this field will not be present.
	RoundedStartTime *time.Time `json:"rounded_start_time,omitempty"`

	// ShiftId A shift tied to this time. 0 if unassigned.
	ShiftId *int `json:"shift_id,omitempty"`

	// SiteId Site the time belongs to. 0 if unassigned.
	SiteId *int `json:"site_id,omitempty"`

	// StartTime The start time. For accounts with Check payroll onboarded, time must not be past the end of the current pay period
	StartTime *time.Time `json:"start_time,omitempty"`

	// UserId The user assigned to the times.
	UserId *int `json:"user_id,omitempty"`
}

// Timezone defines model for Timezone.
type Timezone struct {
	Name string `json:"name"`
}

// User defines model for User.
type User struct {
	// AccountId ID of the primary account for this user.
	AccountId *int `json:"account_id,omitempty"`

	// Activated Whether the manager has activated this user.
	Activated *bool `json:"activated,omitempty"`

	// Email The email address of this user.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeCode The user's employee code. This code can be used to clock in instead of the user's email address, or it can be used to help map users in When I Work to other services.
	EmployeeCode *string `json:"employee_code,omitempty"`

	// FirstName The first name of this user.
	FirstName *string `json:"first_name,omitempty"`

	// HourlyRate The base hourly rate for this user. The user can have additional wages based on the position they are working at the time. There is no currency attached, so customers are expected to input correct values for their currency or do their own conversion from USD.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// HoursMax The max hours that this user prefers to work. A manager may still schedule the user beyond this value.
	HoursMax *float32 `json:"hours_max,omitempty"`

	// HoursPreferred The preferred number of hours for this user to work.
	HoursPreferred *float32 `json:"hours_preferred,omitempty"`

	// Id Unique identifier for the user.
	Id *int `json:"id,omitempty"`

	// IsDeleted Whether the user has been deleted.
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// IsHidden Whether the user has been hidden from the scheduler.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPayroll Whether the user has access to payroll. (Only available for managers and supervisors.)
	IsPayroll *bool `json:"is_payroll,omitempty"`

	// IsPrivate Whether the user has privacy enabled, which will hide their contact details from other employees. Supervisors+ can not hide their email/phone from other employees.
	IsPrivate *bool `json:"is_private,omitempty"`

	// IsTrusted Whether the user can edit their own timesheet.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// LastLogin The date and time when this user last logged in.
	LastLogin *time.Time `json:"last_login,omitempty"`

	// LastName The last name of this user.
	LastName *string `json:"last_name,omitempty"`

	// Locations An array of location IDs to be applied to this user.
	Locations *[]int `json:"locations,omitempty"`

	// LoginId Unique identifier for the login belonging to the user.
	LoginId *int `json:"login_id,omitempty"`

	// Notes Notes about this user. Visible only to supervisors+.
	Notes *string `json:"notes,omitempty"`

	// PhoneNumber The phone number of this user.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Positions An array of position IDs to be assigned to this user.
	Positions *[]int `json:"positions,omitempty"`

	// Role The user's role.
	Role *UserRole `json:"role,omitempty"`

	// Type A bitwise flag representing additional wage options.
	Type *UserType `json:"type,omitempty"`
}

// UserRole The user's role.
type UserRole string

// UserType A bitwise flag representing additional wage options.
type UserType int

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// WKey The developer key
	WKey string `json:"W-Key"`

	// WUserID The user id
	WUserID *string `json:"W-UserID,omitempty"`
}

// GetShiftsParams defines parameters for GetShifts.
type GetShiftsParams struct {
	// UserId The user id to filter by
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Start The start of the filter range.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The end of the filter range.
	End *string `form:"end,omitempty" json:"end,omitempty"`

	// Unpublished Whether or not to include unpublished shifts. Requires supervisor rights.
	Unpublished *bool `form:"unpublished,omitempty" json:"unpublished,omitempty"`

	// IncludeOpen Whether or not to include open shifts from the user's assigned Schedules.
	IncludeOpen *bool `form:"include_open,omitempty" json:"include_open,omitempty"`

	// IncludeOnlyopen Whether or not to include only open shifts from the user's assigned Schedules.
	IncludeOnlyopen *bool `form:"include_onlyopen,omitempty" json:"include_onlyopen,omitempty"`

	// IncludeAllopen Whether to include open shifts across All Schedules. Requires "Manager or Admin access" level.
	IncludeAllopen *bool `form:"include_allopen,omitempty" json:"include_allopen,omitempty"`

	// Deleted Whether to include a list of shift IDs ("deleted_ids") that were deleted during the passed time window.
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`

	// IncludeSwaps Whether or not to include swap requests.
	IncludeSwaps *bool `form:"include_swaps,omitempty" json:"include_swaps,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllLocations Whether to include data from all locations. Shifts are marked as "readonly" if not a manager user.
	AllLocations *bool `form:"all_locations,omitempty" json:"all_locations,omitempty"`

	// LocationId One or more location IDs by which to limit results
	LocationId *string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// ShiftSort True to sort results by user_id, false to sort by shift time. Missing for default sort
	ShiftSort *bool `form:"shift_sort,omitempty" json:"shift_sort,omitempty"`

	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`

	// TrimOpenshifts Setting to true will work w/ the Allow Partial Openshifts feature to display trimmed start/end times for
	// users that can take a conflicting openshift based on the account settings.
	TrimOpenshifts *bool `form:"trim_openshifts,omitempty" json:"trim_openshifts,omitempty"`

	// LimitByRules Setting to true will work w/ the Scheduling Rules feature to only return OpenShifts that the requester is eligible for
	// according to the scheduling rules settings for the account.
	LimitByRules *bool `form:"limit_by_rules,omitempty" json:"limit_by_rules,omitempty"`

	// WUserID The user to select account context for
	WUserID *string `json:"W-UserID,omitempty"`
}

// BulkUpdateShiftsParams defines parameters for BulkUpdateShifts.
type BulkUpdateShiftsParams struct {
	// AssignOpenshiftInstances When set to true, any multiple instance openshifts that are being assigned will assign only one openshift off the stack rather than the entire stack.
	AssignOpenshiftInstances *bool `form:"assign_openshift_instances,omitempty" json:"assign_openshift_instances,omitempty"`
}

// DeleteShiftParams defines parameters for DeleteShift.
type DeleteShiftParams struct {
	// Message Used to notify the shift's assignee that their shift has been deleted. Your message will be added to the notification email. If you want to send the notification email without a message, simply send a single space. Must be URL encoded.
	Message *string `form:"message,omitempty" json:"message,omitempty"`

	// Chain Only applies to repeating shifts. Any value will delete the shift and all shifts that come after it on the chain.
	Chain *string `form:"chain,omitempty" json:"chain,omitempty"`
}

// GetShiftParams defines parameters for GetShift.
type GetShiftParams struct {
	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`
}

// UpdateShiftJSONBody defines parameters for UpdateShift.
type UpdateShiftJSONBody struct {
	union json.RawMessage
}

// UpdateShiftParams defines parameters for UpdateShift.
type UpdateShiftParams struct {
	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`
}

// UpdateShiftJSONBody1 defines parameters for UpdateShift.
type UpdateShiftJSONBody1 = []Shift

// GetSitesParams defines parameters for GetSites.
type GetSitesParams struct {
	// IncludeDeleted Include deleted sites
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// GetTimesParams defines parameters for GetTimes.
type GetTimesParams struct {
	// Start The start of the filter range.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The end of the filter range.
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// UserId List of user ids to filter on
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// OnlyOpen Return only times without an end time
	OnlyOpen *bool `form:"only_open,omitempty" json:"only_open,omitempty"`

	// UpdatedAt Only return times that have been updated since the provided timestamp.
	UpdatedAt *time.Time `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// OverwriteWithRounded Flag to overwrite the start/end/length values with their rounded counterparts (if account setting is enabled)
	OverwriteWithRounded *int `form:"overwrite_with_rounded,omitempty" json:"overwrite_with_rounded,omitempty"`

	// IncludePaidBreakNote Returns the note for a Shift Break Paid Record. Deprecated - please refer to the break attestation docs [here](#tag/Break-Attestation)
	IncludePaidBreakNote *bool `form:"include_paid_break_note,omitempty" json:"include_paid_break_note,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// BulkUpdateShiftsJSONRequestBody defines body for BulkUpdateShifts for application/json ContentType.
type BulkUpdateShiftsJSONRequestBody = BulkEditShiftRequest

// UpdateShiftJSONRequestBody defines body for UpdateShift for application/json ContentType.
type UpdateShiftJSONRequestBody UpdateShiftJSONBody

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = SiteRequest

// UpdateSiteJSONRequestBody defines body for UpdateSite for application/json ContentType.
type UpdateSiteJSONRequestBody = SiteRequest

// CreateTimeJSONRequestBody defines body for CreateTime for application/json ContentType.
type CreateTimeJSONRequestBody = TimeRequest

// UpdateTimeJSONRequestBody defines body for UpdateTime for application/json ContentType.
type UpdateTimeJSONRequestBody = TimeRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShifts request
	GetShifts(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateShiftsWithBody request with any body
	BulkUpdateShiftsWithBody(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateShifts(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShift request
	DeleteShift(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShift request
	GetShift(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShiftWithBody request with any body
	UpdateShiftWithBody(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShift(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSites request
	GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSite request
	DeleteSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSiteWithBody request with any body
	UpdateSiteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSite(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimes request
	GetTimes(ctx context.Context, params *GetTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTimeWithBody request with any body
	CreateTimeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTime(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTime request
	DeleteTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTime request
	GetTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTimeWithBody request with any body
	UpdateTimeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTime(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShifts(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateShiftsWithBody(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateShiftsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateShifts(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateShiftsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShift(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShiftRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShift(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShiftWithBody(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShiftRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShift(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShiftRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSiteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSiteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSite(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSiteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimes(ctx context.Context, params *GetTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTimeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTime(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTimeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTime(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-Key", runtime.ParamLocationHeader, params.WKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("W-Key", headerParam0)

		if params.WUserID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam1)
		}

	}

	return req, nil
}

// NewGetShiftsRequest generates requests for GetShifts
func NewGetShiftsRequest(server string, params *GetShiftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unpublished != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unpublished", runtime.ParamLocationQuery, *params.Unpublished); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOpen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_open", runtime.ParamLocationQuery, *params.IncludeOpen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOnlyopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_onlyopen", runtime.ParamLocationQuery, *params.IncludeOnlyopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAllopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_allopen", runtime.ParamLocationQuery, *params.IncludeAllopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSwaps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_swaps", runtime.ParamLocationQuery, *params.IncludeSwaps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_locations", runtime.ParamLocationQuery, *params.AllLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShiftSort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_sort", runtime.ParamLocationQuery, *params.ShiftSort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrimOpenshifts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trim_openshifts", runtime.ParamLocationQuery, *params.TrimOpenshifts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitByRules != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_by_rules", runtime.ParamLocationQuery, *params.LimitByRules); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.WUserID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam0)
		}

	}

	return req, nil
}

// NewBulkUpdateShiftsRequest calls the generic BulkUpdateShifts builder with application/json body
func NewBulkUpdateShiftsRequest(server string, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateShiftsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBulkUpdateShiftsRequestWithBody generates requests for BulkUpdateShifts with any type of body
func NewBulkUpdateShiftsRequestWithBody(server string, params *BulkUpdateShiftsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssignOpenshiftInstances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assign_openshift_instances", runtime.ParamLocationQuery, *params.AssignOpenshiftInstances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShiftRequest generates requests for DeleteShift
func NewDeleteShiftRequest(server string, id int, params *DeleteShiftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Chain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShiftRequest generates requests for GetShift
func NewGetShiftRequest(server string, id int, params *GetShiftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShiftRequest calls the generic UpdateShift builder with application/json body
func NewUpdateShiftRequest(server string, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShiftRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateShiftRequestWithBody generates requests for UpdateShift with any type of body
func NewUpdateShiftRequestWithBody(server string, id int, params *UpdateShiftParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSitesRequest generates requests for GetSites
func NewGetSitesRequest(server string, params *GetSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteRequest generates requests for DeleteSite
func NewDeleteSiteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSiteRequest calls the generic UpdateSite builder with application/json body
func NewUpdateSiteRequest(server string, id int, body UpdateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSiteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSiteRequestWithBody generates requests for UpdateSite with any type of body
func NewUpdateSiteRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTimesRequest generates requests for GetTimes
func NewGetTimesRequest(server string, params *GetTimesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyOpen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_open", runtime.ParamLocationQuery, *params.OnlyOpen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OverwriteWithRounded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite_with_rounded", runtime.ParamLocationQuery, *params.OverwriteWithRounded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePaidBreakNote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_paid_break_note", runtime.ParamLocationQuery, *params.IncludePaidBreakNote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTimeRequest calls the generic CreateTime builder with application/json body
func NewCreateTimeRequest(server string, body CreateTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTimeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTimeRequestWithBody generates requests for CreateTime with any type of body
func NewCreateTimeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTimeRequest generates requests for DeleteTime
func NewDeleteTimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeRequest generates requests for GetTime
func NewGetTimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTimeRequest calls the generic UpdateTime builder with application/json body
func NewUpdateTimeRequest(server string, id int, body UpdateTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTimeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTimeRequestWithBody generates requests for UpdateTime with any type of body
func NewUpdateTimeRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// GetShiftsWithResponse request
	GetShiftsWithResponse(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*GetShiftsResponse, error)

	// BulkUpdateShiftsWithBodyWithResponse request with any body
	BulkUpdateShiftsWithBodyWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error)

	BulkUpdateShiftsWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error)

	// DeleteShiftWithResponse request
	DeleteShiftWithResponse(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*DeleteShiftResponse, error)

	// GetShiftWithResponse request
	GetShiftWithResponse(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*GetShiftResponse, error)

	// UpdateShiftWithBodyWithResponse request with any body
	UpdateShiftWithBodyWithResponse(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error)

	UpdateShiftWithResponse(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error)

	// GetSitesWithResponse request
	GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	// DeleteSiteWithResponse request
	DeleteSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSiteResponse, error)

	// UpdateSiteWithBodyWithResponse request with any body
	UpdateSiteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error)

	UpdateSiteWithResponse(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error)

	// GetTimesWithResponse request
	GetTimesWithResponse(ctx context.Context, params *GetTimesParams, reqEditors ...RequestEditorFn) (*GetTimesResponse, error)

	// CreateTimeWithBodyWithResponse request with any body
	CreateTimeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error)

	CreateTimeWithResponse(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error)

	// DeleteTimeWithResponse request
	DeleteTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTimeResponse, error)

	// GetTimeWithResponse request
	GetTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTimeResponse, error)

	// UpdateTimeWithBodyWithResponse request with any body
	UpdateTimeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error)

	UpdateTimeWithResponse(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error)
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts *[]Account `json:"accounts,omitempty"`
		Login    *Login     `json:"login,omitempty"`
		Token    *string    `json:"token,omitempty"`
		Users    *[]User    `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
		// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
		// first up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

		// Shiftchains Any shift chains that the fetched shifts are a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		Shifts      *[]Shift      `json:"shifts,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Shifts Array of shift objects to update
		Shifts *[]Shift `json:"shifts,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r BulkUpdateShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted The IDs of the shifts that were deleted
		Deleted *[]int `json:"deleted,omitempty"`

		// Success Whether deletion was successful. If absent, it means nothing was actually deleted.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. If the fetched shift has a shift chain, we will insert all the shifts on that chain from the first up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
		Shift           *Shift   `json:"shift,omitempty"`

		// Shiftchains Any shift chain this shift is a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted A list of shift IDs that were deleted as a result of the update. Applicable for updates to repeating shifts that impact future shifts on the same chain.
		Deleted *[]int `json:"deleted,omitempty"`

		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. We will insert the created or edited shifts from the beginning of the chain up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
		Shift           *Shift   `json:"shift,omitempty"`

		// Shiftchains Any shift chain this shift is a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Sites *[]Site `json:"sites,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether deletion was successful.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Times *[]Time `json:"times,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetTimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether deletion was successful.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// GetShiftsWithResponse request returning *GetShiftsResponse
func (c *ClientWithResponses) GetShiftsWithResponse(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*GetShiftsResponse, error) {
	rsp, err := c.GetShifts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftsResponse(rsp)
}

// BulkUpdateShiftsWithBodyWithResponse request with arbitrary body returning *BulkUpdateShiftsResponse
func (c *ClientWithResponses) BulkUpdateShiftsWithBodyWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error) {
	rsp, err := c.BulkUpdateShiftsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateShiftsResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateShiftsWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error) {
	rsp, err := c.BulkUpdateShifts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateShiftsResponse(rsp)
}

// DeleteShiftWithResponse request returning *DeleteShiftResponse
func (c *ClientWithResponses) DeleteShiftWithResponse(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*DeleteShiftResponse, error) {
	rsp, err := c.DeleteShift(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShiftResponse(rsp)
}

// GetShiftWithResponse request returning *GetShiftResponse
func (c *ClientWithResponses) GetShiftWithResponse(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*GetShiftResponse, error) {
	rsp, err := c.GetShift(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftResponse(rsp)
}

// UpdateShiftWithBodyWithResponse request with arbitrary body returning *UpdateShiftResponse
func (c *ClientWithResponses) UpdateShiftWithBodyWithResponse(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error) {
	rsp, err := c.UpdateShiftWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShiftResponse(rsp)
}

func (c *ClientWithResponses) UpdateShiftWithResponse(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error) {
	rsp, err := c.UpdateShift(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShiftResponse(rsp)
}

// GetSitesWithResponse request returning *GetSitesResponse
func (c *ClientWithResponses) GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error) {
	rsp, err := c.GetSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitesResponse(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResponse
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSiteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

// DeleteSiteWithResponse request returning *DeleteSiteResponse
func (c *ClientWithResponses) DeleteSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error) {
	rsp, err := c.DeleteSite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteResponse(rsp)
}

// GetSiteWithResponse request returning *GetSiteResponse
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSiteResponse, error) {
	rsp, err := c.GetSite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResponse(rsp)
}

// UpdateSiteWithBodyWithResponse request with arbitrary body returning *UpdateSiteResponse
func (c *ClientWithResponses) UpdateSiteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error) {
	rsp, err := c.UpdateSiteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSiteResponse(rsp)
}

func (c *ClientWithResponses) UpdateSiteWithResponse(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error) {
	rsp, err := c.UpdateSite(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSiteResponse(rsp)
}

// GetTimesWithResponse request returning *GetTimesResponse
func (c *ClientWithResponses) GetTimesWithResponse(ctx context.Context, params *GetTimesParams, reqEditors ...RequestEditorFn) (*GetTimesResponse, error) {
	rsp, err := c.GetTimes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimesResponse(rsp)
}

// CreateTimeWithBodyWithResponse request with arbitrary body returning *CreateTimeResponse
func (c *ClientWithResponses) CreateTimeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error) {
	rsp, err := c.CreateTimeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimeResponse(rsp)
}

func (c *ClientWithResponses) CreateTimeWithResponse(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error) {
	rsp, err := c.CreateTime(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimeResponse(rsp)
}

// DeleteTimeWithResponse request returning *DeleteTimeResponse
func (c *ClientWithResponses) DeleteTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTimeResponse, error) {
	rsp, err := c.DeleteTime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTimeResponse(rsp)
}

// GetTimeWithResponse request returning *GetTimeResponse
func (c *ClientWithResponses) GetTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTimeResponse, error) {
	rsp, err := c.GetTime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeResponse(rsp)
}

// UpdateTimeWithBodyWithResponse request with arbitrary body returning *UpdateTimeResponse
func (c *ClientWithResponses) UpdateTimeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error) {
	rsp, err := c.UpdateTimeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimeResponse(rsp)
}

func (c *ClientWithResponses) UpdateTimeWithResponse(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error) {
	rsp, err := c.UpdateTime(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimeResponse(rsp)
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts *[]Account `json:"accounts,omitempty"`
			Login    *Login     `json:"login,omitempty"`
			Token    *string    `json:"token,omitempty"`
			Users    *[]User    `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetShiftsResponse parses an HTTP response from a GetShiftsWithResponse call
func ParseGetShiftsResponse(rsp *http.Response) (*GetShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
			// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
			// first up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

			// Shiftchains Any shift chains that the fetched shifts are a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
			Shifts      *[]Shift      `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBulkUpdateShiftsResponse parses an HTTP response from a BulkUpdateShiftsWithResponse call
func ParseBulkUpdateShiftsResponse(rsp *http.Response) (*BulkUpdateShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Shifts Array of shift objects to update
			Shifts *[]Shift `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteShiftResponse parses an HTTP response from a DeleteShiftWithResponse call
func ParseDeleteShiftResponse(rsp *http.Response) (*DeleteShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted The IDs of the shifts that were deleted
			Deleted *[]int `json:"deleted,omitempty"`

			// Success Whether deletion was successful. If absent, it means nothing was actually deleted.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetShiftResponse parses an HTTP response from a GetShiftWithResponse call
func ParseGetShiftResponse(rsp *http.Response) (*GetShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. If the fetched shift has a shift chain, we will insert all the shifts on that chain from the first up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
			Shift           *Shift   `json:"shift,omitempty"`

			// Shiftchains Any shift chain this shift is a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateShiftResponse parses an HTTP response from a UpdateShiftWithResponse call
func ParseUpdateShiftResponse(rsp *http.Response) (*UpdateShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted A list of shift IDs that were deleted as a result of the update. Applicable for updates to repeating shifts that impact future shifts on the same chain.
			Deleted *[]int `json:"deleted,omitempty"`

			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. We will insert the created or edited shifts from the beginning of the chain up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
			Shift           *Shift   `json:"shift,omitempty"`

			// Shiftchains Any shift chain this shift is a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSitesResponse parses an HTTP response from a GetSitesWithResponse call
func ParseGetSitesResponse(rsp *http.Response) (*GetSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Sites *[]Site `json:"sites,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSiteResponse parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResponse(rsp *http.Response) (*CreateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSiteResponse parses an HTTP response from a DeleteSiteWithResponse call
func ParseDeleteSiteResponse(rsp *http.Response) (*DeleteSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether deletion was successful.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSiteResponse parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResponse(rsp *http.Response) (*GetSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSiteResponse parses an HTTP response from a UpdateSiteWithResponse call
func ParseUpdateSiteResponse(rsp *http.Response) (*UpdateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimesResponse parses an HTTP response from a GetTimesWithResponse call
func ParseGetTimesResponse(rsp *http.Response) (*GetTimesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Times *[]Time `json:"times,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTimeResponse parses an HTTP response from a CreateTimeWithResponse call
func ParseCreateTimeResponse(rsp *http.Response) (*CreateTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTimeResponse parses an HTTP response from a DeleteTimeWithResponse call
func ParseDeleteTimeResponse(rsp *http.Response) (*DeleteTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether deletion was successful.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimeResponse parses an HTTP response from a GetTimeWithResponse call
func ParseGetTimeResponse(rsp *http.Response) (*GetTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTimeResponse parses an HTTP response from a UpdateTimeWithResponse call
func ParseUpdateTimeResponse(rsp *http.Response) (*UpdateTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
