// Package wheniwork provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package wheniwork

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	W_TokenScopes = "W_Token.Scopes"
)

// Defines values for UserRole.
const (
	N1Admin           UserRole = "1 = Admin"
	N2Manager         UserRole = "2 = Manager"
	N3EmployeeDefault UserRole = "3 = Employee (Default)"
	N4LeadUnused      UserRole = "4 = Lead (Unused)"
	N5Supervisor      UserRole = "5 = Supervisor"
)

// Defines values for UserType.
const (
	N1 UserType = 1
	N2 UserType = 2
	N3 UserType = 3
)

// Account defines model for Account.
type Account struct {
	Company  *string   `json:"company,omitempty"`
	Id       *int      `json:"id,omitempty"`
	Timezone *Timezone `json:"timezone,omitempty"`
}

// BaseScheduledBreak defines model for BaseScheduledBreak.
type BaseScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
	Message *string                 `json:"message,omitempty"`
}

// Login defines model for Login.
type Login struct {
	Avatar *struct {
		Size *int    `json:"size,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"avatar,omitempty"`
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	Email     *openapi_types.Email `json:"email,omitempty"`
	FirstName *string              `json:"first_name,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	LastName  *string              `json:"last_name,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Token     *string              `json:"token,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
}

// Shift defines model for Shift.
type Shift struct {
	AccountId *int `json:"account_id,omitempty"`

	// Acknowledged If enabled; When the user confirmed the shift
	Acknowledged *bool `json:"acknowledged,omitempty"`

	// AcknowledgedAt If enabled; When the user confirmed the shift
	AcknowledgedAt *time.Time `json:"acknowledged_at,omitempty"`

	// Alerted Is the shift Alert sent
	Alerted *bool `json:"alerted,omitempty"`

	// BreakTime Length of the unpaid breaks for the shift in hours.
	BreakTime *float32 `json:"break_time,omitempty"`

	// Breaks An array of breaks for the shift. When updating a shift, any existing breaks for the shift that are not included in the request will be deleted.
	Breaks *[]ShiftScheduledBreak `json:"breaks,omitempty"`

	// Color Assign color to shift
	Color     *string    `json:"color,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatorId The user that created the shift
	CreatorId *int      `json:"creator_id,omitempty"`
	EndTime   time.Time `json:"end_time"`
	Id        *int      `json:"id,omitempty"`
	Instances *int      `json:"instances,omitempty"`

	// IsApprovedWithoutTime Used to indicate that a manager or supervisor has approved a missing time entry for this shift
	IsApprovedWithoutTime *bool `json:"is_approved_without_time,omitempty"`
	IsOpen                *bool `json:"is_open,omitempty"`

	// IsShared Is the shift a shared OpenShift
	IsShared *bool `json:"is_shared,omitempty"`

	// IsTrimmed Is rounding active for shift
	IsTrimmed *bool `json:"is_trimmed,omitempty"`

	// LinkedUsers Array of user IDs that can take this openshift. Null means all users are eligible.
	LinkedUsers *[]int `json:"linked_users,omitempty"`

	// LocationId Location the shift belongs to
	LocationId int `json:"location_id"`

	// Notes Text notation for a Shift
	Notes      *string    `json:"notes,omitempty"`
	NotifiedAt *time.Time `json:"notified_at,omitempty"`

	// OpenshiftApprovalRequestId ID of the associated OpenShift Approval request
	OpenshiftApprovalRequestId *int `json:"openshift_approval_request_id,omitempty"`
	PositionId                 *int `json:"position_id,omitempty"`

	// Published Is the shift published
	Published     *bool      `json:"published,omitempty"`
	PublishedDate *time.Time `json:"published_date,omitempty"`

	// RequiresOpenshiftApproval Does this shift require OpenShift Approval
	RequiresOpenshiftApproval *bool `json:"requires_openshift_approval,omitempty"`

	// ShiftchainKey The ID to associate shifts in a repeating pattern
	ShiftchainKey *string    `json:"shiftchain_key,omitempty"`
	SiteId        *int       `json:"site_id,omitempty"`
	StartTime     time.Time  `json:"start_time"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`

	// UserId The user assigned to the shift. Set to `0` for an Open Shift.
	UserId *int `json:"user_id,omitempty"`
}

// ShiftChain defines model for ShiftChain.
type ShiftChain struct {
	// Count The number of shifts created by this chain.
	// Deprecated:
	Count *int    `json:"count,omitempty"`
	Key   *string `json:"key,omitempty"`

	// Rrule The RFC5545-compliant RRule representing the shift chain.
	Rrule *string `json:"rrule,omitempty"`

	// TimezoneId The timezone this chain is built in
	TimezoneId *string `json:"timezone_id,omitempty"`

	// Until The date when the shift chain ends.
	Until *openapi_types.Date `json:"until,omitempty"`

	// Week Represents the week frequency interval. `1` means weekly, `2` means every two weeks, etc.
	Week *int `json:"week,omitempty"`

	// Weekdays A bitmask of the weekdays which shifts in this chain occur on. In a seven-bit binary number, the most
	// significant bit represents Sunday and the least significant bit represents Monday (0b1000001).
	//
	// Examples:
	// | Days                      | Binary      | Decimal |
	// |---------------------------|-------------|---------|
	// | Monday through Friday     | `0b0011111` | 31      |
	// | Monday, Wednesday, Friday | `0b0010101` | 21      |
	// | Saturday and Sunday       | `0b1100000` | 96      |
	Weekdays *int `json:"weekdays,omitempty"`
}

// ShiftScheduledBreak defines model for ShiftScheduledBreak.
type ShiftScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// EndTime The end time of the break. Null if the break does not have an end time. Calculated from the start time of the break and the length.
	EndTime *string `json:"end_time,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// ShiftId The ID of the shift that the break applies to.
	ShiftId *int `json:"shift_id,omitempty"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// StartTime The start time of the break. Null if the break does not have a start time.
	StartTime *string `json:"start_time,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// Timezone defines model for Timezone.
type Timezone struct {
	Name string `json:"name"`
}

// User defines model for User.
type User struct {
	// AccountId ID of the primary account for this user.
	AccountId *int `json:"account_id,omitempty"`

	// Activated Whether the manager has activated this user.
	Activated *bool `json:"activated,omitempty"`

	// Email The email address of this user.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeCode The user's employee code. This code can be used to clock in instead of the user's email address, or it can be used to help map users in When I Work to other services.
	EmployeeCode *string `json:"employee_code,omitempty"`

	// FirstName The first name of this user.
	FirstName *string `json:"first_name,omitempty"`

	// HourlyRate The base hourly rate for this user. The user can have additional wages based on the position they are working at the time. There is no currency attached, so customers are expected to input correct values for their currency or do their own conversion from USD.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// HoursMax The max hours that this user prefers to work. A manager may still schedule the user beyond this value.
	HoursMax *float32 `json:"hours_max,omitempty"`

	// HoursPreferred The preferred number of hours for this user to work.
	HoursPreferred *float32 `json:"hours_preferred,omitempty"`

	// Id Unique identifier for the user.
	Id *int `json:"id,omitempty"`

	// IsDeleted Whether the user has been deleted.
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// IsHidden Whether the user has been hidden from the scheduler.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPayroll Whether the user has access to payroll. (Only available for managers and supervisors.)
	IsPayroll *bool `json:"is_payroll,omitempty"`

	// IsPrivate Whether the user has privacy enabled, which will hide their contact details from other employees. Supervisors+ can not hide their email/phone from other employees.
	IsPrivate *bool `json:"is_private,omitempty"`

	// IsTrusted Whether the user can edit their own timesheet.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// LastLogin The date and time when this user last logged in.
	LastLogin *time.Time `json:"last_login,omitempty"`

	// LastName The last name of this user.
	LastName *string `json:"last_name,omitempty"`

	// Locations An array of location IDs to be applied to this user.
	Locations *[]int `json:"locations,omitempty"`

	// LoginId Unique identifier for the login belonging to the user.
	LoginId *int `json:"login_id,omitempty"`

	// Notes Notes about this user. Visible only to supervisors+.
	Notes *string `json:"notes,omitempty"`

	// PhoneNumber The phone number of this user.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Positions An array of position IDs to be assigned to this user.
	Positions *[]int `json:"positions,omitempty"`

	// Role The user's role.
	Role *UserRole `json:"role,omitempty"`

	// Type A bitwise flag representing additional wage options.
	Type *UserType `json:"type,omitempty"`
}

// UserRole The user's role.
type UserRole string

// UserType A bitwise flag representing additional wage options.
type UserType int

// GetShiftsParams defines parameters for GetShifts.
type GetShiftsParams struct {
	// UserId The user id to filter by
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Start The start of the filter range.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The end of the filter range.
	End *string `form:"end,omitempty" json:"end,omitempty"`

	// Unpublished Whether or not to include unpublished shifts. Requires supervisor rights.
	Unpublished *bool `form:"unpublished,omitempty" json:"unpublished,omitempty"`

	// IncludeOpen Whether or not to include open shifts from the user's assigned Schedules.
	IncludeOpen *bool `form:"include_open,omitempty" json:"include_open,omitempty"`

	// IncludeOnlyopen Whether or not to include only open shifts from the user's assigned Schedules.
	IncludeOnlyopen *bool `form:"include_onlyopen,omitempty" json:"include_onlyopen,omitempty"`

	// IncludeAllopen Whether or to include open shifts across All Schedules. Requires "Manager or Admin access" level.
	IncludeAllopen *bool `form:"include_allopen,omitempty" json:"include_allopen,omitempty"`

	// Deleted Whether to include a list of shift IDs ("deleted_ids") that were deleted during the passed time window.
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`

	// IncludeSwaps Whether or not to include swap requests.
	IncludeSwaps *bool `form:"include_swaps,omitempty" json:"include_swaps,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllLocations Whether to include data from all locations. Shifts are marked as "readonly" if not a manager user.
	AllLocations *bool `form:"all_locations,omitempty" json:"all_locations,omitempty"`

	// LocationId One or more location IDs by which to limit results
	LocationId *string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// ShiftSort True to sort results by user_id, false to sort by shift time. Missing for default sort
	ShiftSort *bool `form:"shift_sort,omitempty" json:"shift_sort,omitempty"`

	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`

	// TrimOpenshifts Setting to true will work w/ the Allow Partial Openshifts feature to display trimmed start/end times for
	// users that can take a conflicting openshift based on the account settings.
	TrimOpenshifts *bool `form:"trim_openshifts,omitempty" json:"trim_openshifts,omitempty"`

	// LimitByRules Setting to true will work w/ the Scheduling Rules feature to only return OpenShifts that the requester is eligible for
	// according to the scheduling rules settings for the account.
	LimitByRules *bool `form:"limit_by_rules,omitempty" json:"limit_by_rules,omitempty"`

	// WUserID The user to select account context for
	WUserID *string `json:"W-UserID,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// WKey The developer key
	WKey string `json:"W-Key"`

	// WUserID The user id
	WUserID *string `json:"W-UserID,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetShifts request
	GetShifts(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetShifts(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetShiftsRequest generates requests for GetShifts
func NewGetShiftsRequest(server string, params *GetShiftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unpublished != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unpublished", runtime.ParamLocationQuery, *params.Unpublished); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOpen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_open", runtime.ParamLocationQuery, *params.IncludeOpen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOnlyopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_onlyopen", runtime.ParamLocationQuery, *params.IncludeOnlyopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAllopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_allopen", runtime.ParamLocationQuery, *params.IncludeAllopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSwaps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_swaps", runtime.ParamLocationQuery, *params.IncludeSwaps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_locations", runtime.ParamLocationQuery, *params.AllLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShiftSort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_sort", runtime.ParamLocationQuery, *params.ShiftSort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrimOpenshifts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trim_openshifts", runtime.ParamLocationQuery, *params.TrimOpenshifts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitByRules != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_by_rules", runtime.ParamLocationQuery, *params.LimitByRules); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.WUserID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam0)
		}

	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-Key", runtime.ParamLocationHeader, params.WKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("W-Key", headerParam0)

		if params.WUserID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetShiftsWithResponse request
	GetShiftsWithResponse(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*GetShiftsResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)
}

type GetShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
		// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
		// first up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

		// Shiftchains Any shift chains that the fetched shifts are a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		Shifts      *[]Shift      `json:"shifts,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts *[]Account `json:"accounts,omitempty"`
		Login    *Login     `json:"login,omitempty"`
		Token    *string    `json:"token,omitempty"`
		Users    *[]User    `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetShiftsWithResponse request returning *GetShiftsResponse
func (c *ClientWithResponses) GetShiftsWithResponse(ctx context.Context, params *GetShiftsParams, reqEditors ...RequestEditorFn) (*GetShiftsResponse, error) {
	rsp, err := c.GetShifts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftsResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ParseGetShiftsResponse parses an HTTP response from a GetShiftsWithResponse call
func ParseGetShiftsResponse(rsp *http.Response) (*GetShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
			// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
			// first up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

			// Shiftchains Any shift chains that the fetched shifts are a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
			Shifts      *[]Shift      `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts *[]Account `json:"accounts,omitempty"`
			Login    *Login     `json:"login,omitempty"`
			Token    *string    `json:"token,omitempty"`
			Users    *[]User    `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
