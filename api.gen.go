// Package wheniwork provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package wheniwork

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	W_TokenScopes = "W_Token.Scopes"
)

// Defines values for ShiftHistoryAttributesReason.
const (
	Assign                     ShiftHistoryAttributesReason = "assign"
	AssignApprove              ShiftHistoryAttributesReason = "assign-approve"
	CreatedFromRepeatingSeries ShiftHistoryAttributesReason = "created-from-repeating-series"
	Delete                     ShiftHistoryAttributesReason = "delete"
	DeleteBulk                 ShiftHistoryAttributesReason = "delete-bulk"
	DeleteClear                ShiftHistoryAttributesReason = "delete-clear"
	DeletedAssignedUser        ShiftHistoryAttributesReason = "deleted-assigned-user"
	Drop                       ShiftHistoryAttributesReason = "drop"
	Edit                       ShiftHistoryAttributesReason = "edit"
	OverwriteConflictsDelete   ShiftHistoryAttributesReason = "overwrite-conflicts-delete"
	Publish                    ShiftHistoryAttributesReason = "publish"
	RepeatingDelete            ShiftHistoryAttributesReason = "repeating-delete"
	Split                      ShiftHistoryAttributesReason = "split"
	Swap                       ShiftHistoryAttributesReason = "swap"
	Take                       ShiftHistoryAttributesReason = "take"
	Unpublish                  ShiftHistoryAttributesReason = "unpublish"
	UpdatedFromRepeatingSeries ShiftHistoryAttributesReason = "updated-from-repeating-series"
	UserRemovedFromSchedule    ShiftHistoryAttributesReason = "user-removed-from-schedule"
)

// Defines values for ShiftHistoryType.
const (
	Accepted        ShiftHistoryType = "accepted"
	BreakChanged    ShiftHistoryType = "break_changed"
	BreakRemoved    ShiftHistoryType = "break_removed"
	Confirmed       ShiftHistoryType = "confirmed"
	Created         ShiftHistoryType = "created"
	Current         ShiftHistoryType = "current"
	Deleted         ShiftHistoryType = "deleted"
	LocationChanged ShiftHistoryType = "location_changed"
	PositionChanged ShiftHistoryType = "position_changed"
	PositionRemoved ShiftHistoryType = "position_removed"
	Published       ShiftHistoryType = "published"
	Reassigned      ShiftHistoryType = "reassigned"
	Released        ShiftHistoryType = "released"
	SiteChanged     ShiftHistoryType = "site_changed"
	SiteRemoved     ShiftHistoryType = "site_removed"
	Taken           ShiftHistoryType = "taken"
	TimeChanged     ShiftHistoryType = "time_changed"
	Unpublished     ShiftHistoryType = "unpublished"
)

// Defines values for UpdateUserRequestRole.
const (
	UpdateUserRequestRoleN1Admin           UpdateUserRequestRole = "1 = Admin"
	UpdateUserRequestRoleN2Manager         UpdateUserRequestRole = "2 = Manager"
	UpdateUserRequestRoleN3EmployeeDefault UpdateUserRequestRole = "3 = Employee (Default)"
	UpdateUserRequestRoleN4LeadUnused      UpdateUserRequestRole = "4 = Lead (Unused)"
	UpdateUserRequestRoleN5Supervisor      UpdateUserRequestRole = "5 = Supervisor"
)

// Defines values for UpdateUserRequestType.
const (
	UpdateUserRequestTypeN1 UpdateUserRequestType = 1
	UpdateUserRequestTypeN2 UpdateUserRequestType = 2
	UpdateUserRequestTypeN3 UpdateUserRequestType = 3
)

// Defines values for UserRole.
const (
	UserRoleN1Admin           UserRole = "1 = Admin"
	UserRoleN2Manager         UserRole = "2 = Manager"
	UserRoleN3EmployeeDefault UserRole = "3 = Employee (Default)"
	UserRoleN4LeadUnused      UserRole = "4 = Lead (Unused)"
	UserRoleN5Supervisor      UserRole = "5 = Supervisor"
)

// Defines values for UserType.
const (
	UserTypeN1 UserType = 1
	UserTypeN2 UserType = 2
	UserTypeN3 UserType = 3
)

// Defines values for UserRequestRole.
const (
	N1Admin           UserRequestRole = "1 = Admin"
	N2Manager         UserRequestRole = "2 = Manager"
	N3EmployeeDefault UserRequestRole = "3 = Employee (Default)"
	N4LeadUnused      UserRequestRole = "4 = Lead (Unused)"
	N5Supervisor      UserRequestRole = "5 = Supervisor"
)

// Defines values for UserRequestType.
const (
	N1 UserRequestType = 1
	N2 UserRequestType = 2
	N3 UserRequestType = 3
)

// Account defines model for Account.
type Account struct {
	Company  *string   `json:"company,omitempty"`
	Id       *int      `json:"id,omitempty"`
	Timezone *Timezone `json:"timezone,omitempty"`
}

// BaseScheduledBreak defines model for BaseScheduledBreak.
type BaseScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// BulkEditShiftRequest Array of shift objects to update
type BulkEditShiftRequest = []ShiftBulk

// BulkUserResponse Response for both Valid/Invalid requests
type BulkUserResponse struct {
	// Count The total number of invites sent.
	Count *int `json:"count,omitempty"`

	// InvalidRows List of invalid user rows
	InvalidRows *[]struct {
		// Row The row number in the input array.
		Row  *int  `json:"row,omitempty"`
		User *User `json:"user,omitempty"`
	} `json:"invalidRows,omitempty"`

	// Locations An array of locations (schedules) assigned to this user.
	Locations *[]int `json:"locations,omitempty"`

	// Success True if at least one invite was sent.
	Success *bool `json:"success,omitempty"`

	// ValidRows List of valid user rows
	ValidRows *[]struct {
		// Row The row number in the input array.
		Row  *int  `json:"row,omitempty"`
		User *User `json:"user,omitempty"`
	} `json:"validRows,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
	Message *string                 `json:"message,omitempty"`
}

// InviteUserRequest defines model for InviteUserRequest.
type InviteUserRequest struct {
	// Ids List of existing user IDs to invite.
	Ids *[]int `json:"ids,omitempty"`

	// Message An optional message to include in the email invite.
	Message *string `json:"message,omitempty"`

	// SendAll Whether to invite all users who do not currently have a login/person. If this is true, the ids parameter will be ignored. Defaults to false.
	SendAll *bool `json:"send_all,omitempty"`
}

// InviteUserResponse Valid
type InviteUserResponse struct {
	// Count The total number of invites sent.
	Count *int `json:"count,omitempty"`

	// Email The total number of invites sent via email.
	Email *int `json:"email,omitempty"`

	// Sms The total number of invites sent via text message.
	Sms *int `json:"sms,omitempty"`

	// Success True if at least one invite was sent.
	Success *bool `json:"success,omitempty"`
}

// Login defines model for Login.
type Login struct {
	Avatar *struct {
		Size *int    `json:"size,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"avatar,omitempty"`
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	Email     *openapi_types.Email `json:"email,omitempty"`
	FirstName *string              `json:"first_name,omitempty"`
	Id        *int                 `json:"id,omitempty"`
	LastName  *string              `json:"last_name,omitempty"`
	Name      *string              `json:"name,omitempty"`
	Token     *string              `json:"token,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
}

// OpenShiftApprovalRequest defines model for OpenShiftApprovalRequest.
type OpenShiftApprovalRequest struct {
	// ApprovedAt The date and time when the OpenShift Approval request was approved
	ApprovedAt *time.Time `json:"approved_at,omitempty"`

	// ApprovedBy The ID of the user who approved the OpenShift Approval request
	ApprovedBy *int `json:"approved_by,omitempty"`

	// Id The ID of the OpenShift Approval request
	Id *int `json:"id,omitempty"`

	// IsApproved Whether the OpenShift Approval request is approved
	IsApproved *bool `json:"is_approved,omitempty"`

	// Notes Notes about the OpenShift Approval request
	Notes *string `json:"notes,omitempty"`

	// ShiftId The ID of the shift associated with the OpenShift Approval request
	ShiftId *int `json:"shift_id,omitempty"`

	// UserId The ID of the user associated with the OpenShift Approval request
	UserId *int `json:"user_id,omitempty"`
}

// Place defines model for Place.
type Place struct {
	Address      *string    `json:"address,omitempty"`
	BusinessName *string    `json:"business_name,omitempty"`
	Country      *string    `json:"country,omitempty"`
	Id           *int       `json:"id,omitempty"`
	Latitude     *float32   `json:"latitude,omitempty"`
	Locality     *string    `json:"locality,omitempty"`
	Longitude    *float32   `json:"longitude,omitempty"`
	PlaceId      *string    `json:"place_id,omitempty"`
	PlaceType    *[]string  `json:"place_type,omitempty"`
	PostalCode   *string    `json:"postal_code,omitempty"`
	Region       *string    `json:"region,omitempty"`
	StreetName   *string    `json:"street_name,omitempty"`
	StreetNumber *string    `json:"street_number,omitempty"`
	SubLocality  *string    `json:"sub_locality,omitempty"`
	UpdatedAt    *time.Time `json:"updated_at,omitempty"`
}

// Shift defines model for Shift.
type Shift struct {
	AccountId *int `json:"account_id,omitempty"`

	// Acknowledged If enabled; When the user confirmed the shift
	Acknowledged *bool `json:"acknowledged,omitempty"`

	// AcknowledgedAt If enabled; When the user confirmed the shift
	AcknowledgedAt *time.Time `json:"acknowledged_at,omitempty"`

	// Alerted Is the shift Alert sent
	Alerted *bool `json:"alerted,omitempty"`

	// BreakTime Length of the unpaid breaks for the shift in hours.
	BreakTime *float32 `json:"break_time,omitempty"`

	// Breaks An array of breaks for the shift. When updating a shift, any existing breaks for the shift that are not included in the request will be deleted.
	Breaks *[]ShiftScheduledBreak `json:"breaks,omitempty"`

	// Color Assign color to shift
	Color     *string    `json:"color,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatorId The user that created the shift
	CreatorId *int      `json:"creator_id,omitempty"`
	EndTime   time.Time `json:"end_time"`
	Id        *int      `json:"id,omitempty"`
	Instances *int      `json:"instances,omitempty"`

	// IsApprovedWithoutTime Used to indicate that a manager or supervisor has approved a missing time entry for this shift
	IsApprovedWithoutTime *bool `json:"is_approved_without_time,omitempty"`
	IsOpen                *bool `json:"is_open,omitempty"`

	// IsShared Is the shift a shared OpenShift
	IsShared *bool `json:"is_shared,omitempty"`

	// IsTrimmed Is rounding active for shift
	IsTrimmed *bool `json:"is_trimmed,omitempty"`

	// LinkedUsers Array of user IDs that can take this openshift. Null means all users are eligible.
	LinkedUsers *[]int `json:"linked_users,omitempty"`

	// LocationId Location the shift belongs to
	LocationId int `json:"location_id"`

	// Notes Text notation for a Shift
	Notes      *string    `json:"notes,omitempty"`
	NotifiedAt *time.Time `json:"notified_at,omitempty"`

	// OpenshiftApprovalRequestId ID of the associated OpenShift Approval request
	OpenshiftApprovalRequestId *int `json:"openshift_approval_request_id,omitempty"`
	PositionId                 *int `json:"position_id,omitempty"`

	// Published Is the shift published
	Published     *bool      `json:"published,omitempty"`
	PublishedDate *time.Time `json:"published_date,omitempty"`

	// RequiresOpenshiftApproval Does this shift require OpenShift Approval
	RequiresOpenshiftApproval *bool `json:"requires_openshift_approval,omitempty"`

	// ShiftchainKey The ID to associate shifts in a repeating pattern
	ShiftchainKey *string    `json:"shiftchain_key,omitempty"`
	SiteId        *int       `json:"site_id,omitempty"`
	StartTime     time.Time  `json:"start_time"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`

	// UserId The user assigned to the shift. Set to `0` for an Open Shift.
	UserId *int `json:"user_id,omitempty"`
}

// ShiftAssignRequest defines model for ShiftAssignRequest.
type ShiftAssignRequest struct {
	// ShiftIds Array of shift IDs
	ShiftIds *[]string `json:"shift_ids,omitempty"`
}

// ShiftBulk defines model for ShiftBulk.
type ShiftBulk struct {
	AccountId *int     `json:"account_id,omitempty"`
	BreakTime *float32 `json:"break_time,omitempty"`

	// Color Assign color to shift
	Color   *string   `json:"color,omitempty"`
	EndTime time.Time `json:"end_time"`
	Id      int       `json:"id"`

	// LinkedUsers Array of user IDs that can take this openshift. Null means all users are eligible.
	LinkedUsers *[]int `json:"linked_users,omitempty"`

	// LocationId Location the shift belongs to
	LocationId int `json:"location_id"`

	// Notes Text notation for a Shift
	Notes      *string   `json:"notes,omitempty"`
	PositionId *int      `json:"position_id,omitempty"`
	SiteId     *int      `json:"site_id,omitempty"`
	StartTime  time.Time `json:"start_time"`

	// UserId The user assigned to the shift. Set to `0` for an Open Shift.
	UserId *int `json:"user_id,omitempty"`
}

// ShiftChain defines model for ShiftChain.
type ShiftChain struct {
	// Count The number of shifts created by this chain.
	// Deprecated:
	Count *int    `json:"count,omitempty"`
	Key   *string `json:"key,omitempty"`

	// Rrule The RFC5545-compliant RRule representing the shift chain.
	Rrule *string `json:"rrule,omitempty"`

	// TimezoneId The timezone this chain is built in
	TimezoneId *string `json:"timezone_id,omitempty"`

	// Until The date when the shift chain ends.
	Until *openapi_types.Date `json:"until,omitempty"`

	// Week Represents the week frequency interval. `1` means weekly, `2` means every two weeks, etc.
	Week *int `json:"week,omitempty"`

	// Weekdays A bitmask of the weekdays which shifts in this chain occur on. In a seven-bit binary number, the most
	// significant bit represents Sunday and the least significant bit represents Monday (0b1000001).
	//
	// Examples:
	// | Days                      | Binary      | Decimal |
	// |---------------------------|-------------|---------|
	// | Monday through Friday     | `0b0011111` | 31      |
	// | Monday, Wednesday, Friday | `0b0010101` | 21      |
	// | Saturday and Sunday       | `0b1100000` | 96      |
	Weekdays *int `json:"weekdays,omitempty"`
}

// ShiftHistory defines model for ShiftHistory.
type ShiftHistory struct {
	Attributes *struct {
		// Actor The name of the user that triggered this shift history event
		Actor string `json:"actor"`

		// At The timestamp of when this shift history event was recorded
		At time.Time `json:"at"`

		// Break Present in `created`, `current`, `break_changed` and `break_removed` events . The new value of shift break.
		Break *float32 `json:"break,omitempty"`

		// End Present in `current`, `created`, and `time_changed` events. The new end time.
		End *time.Time `json:"end,omitempty"`

		// Position Present in `current`, `created`, `position_changed` and `position_removed` events. The new position.
		Position *string `json:"position,omitempty"`

		// Reason A reason code to provide additional context for why a shift history event was recorded
		Reason *ShiftHistoryAttributesReason `json:"reason,omitempty"`

		// Site Present in `current`, `created`, `site_changed` and `site_removed` events. The new site.
		Site *string `json:"site,omitempty"`

		// Start Present in `current`, `created`, and `time_changed` events. The new start time.
		Start *time.Time `json:"start,omitempty"`

		// User Present in `current`, `created`, `reassigned`, `taken`, `accepted` and `released` events. The new user assigned to the shift.
		User *string `json:"user,omitempty"`
	} `json:"attributes,omitempty"`

	// Type The type of history event
	Type *ShiftHistoryType `json:"type,omitempty"`
}

// ShiftHistoryAttributesReason A reason code to provide additional context for why a shift history event was recorded
type ShiftHistoryAttributesReason string

// ShiftHistoryType The type of history event
type ShiftHistoryType string

// ShiftNotifyRequest defines model for ShiftNotifyRequest.
type ShiftNotifyRequest struct {
	// All Should notifications be sent for all matching shifts, or only new and/or changed shifts since last notification.
	All *bool `json:"all,omitempty"`

	// End The end of the date range of shifts for which to send notifications
	End time.Time `json:"end"`

	// LocationId The location (schedule) with shifts to send notifications. If not set, all locations will be included.
	LocationId *int `json:"location_id,omitempty"`

	// Message A custom message to send with the shift notifications
	Message *string `json:"message,omitempty"`

	// PositionIds Limit schedule notifications to only shifts tagged to the given position IDs. Defaults to all positions.
	PositionIds *[]int `json:"position_ids,omitempty"`

	// SiteIds Limit schedule notifications to only shifts tagged to the given site IDs. Defaults to all sites.
	SiteIds *[]int `json:"site_ids,omitempty"`

	// Start The start of the date range of shifts for which to send notifications
	Start time.Time `json:"start"`

	// UserIds Limit schedule notifications to only shifts tagged to the given user IDs. Defaults to all users.
	UserIds *[]int `json:"user_ids,omitempty"`
}

// ShiftPublish defines model for ShiftPublish.
type ShiftPublish struct {
	// Ids List of shift IDs
	Ids *[]int `json:"ids,omitempty"`
}

// ShiftScheduledBreak defines model for ShiftScheduledBreak.
type ShiftScheduledBreak struct {
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Date and time the break was created at.
	CreatedAt *string `json:"created_at,omitempty"`

	// CreatedBy The id of the user who created the break.
	CreatedBy *int `json:"created_by,omitempty"`

	// EndTime The end time of the break. Null if the break does not have an end time. Calculated from the start time of the break and the length.
	EndTime *string `json:"end_time,omitempty"`

	// Id ID of the break. Provide in the request when updating an existing break.
	Id *int `json:"id,omitempty"`

	// Length The length of the break (seconds).
	Length int `json:"length"`

	// Paid Whether the break is a paid rest break (true) or unpaid meal break (false)
	Paid bool `json:"paid"`

	// ShiftId The ID of the shift that the break applies to.
	ShiftId *int `json:"shift_id,omitempty"`

	// Sort Breaks are sorted by start time if it is available. If no start time is provided, breaks are sorted by their position in the request. In a mixed list, breaks without a start time keep their original position, while breaks with a start time are sorted amongst themselves.
	Sort *int `json:"sort,omitempty"`

	// StartTime The start time of the break. Null if the break does not have a start time.
	StartTime *string `json:"start_time,omitempty"`

	// UpdatedAt Date and time the break was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UpdatedBy The id of the user who last edited the break.
	UpdatedBy *int `json:"updated_by,omitempty"`
}

// ShiftUnassignRequest defines model for ShiftUnassignRequest.
type ShiftUnassignRequest struct {
	// ShiftIds Array of shift IDs
	ShiftIds *[]string `json:"shift_ids,omitempty"`
}

// SingleShiftNotifyRequest defines model for SingleShiftNotifyRequest.
type SingleShiftNotifyRequest struct {
	// Message A custom message to send with the shift notifications.
	Message *string `json:"message,omitempty"`
}

// Site defines model for Site.
type Site struct {
	AccountId   *int       `json:"account_id,omitempty"`
	Address     *string    `json:"address,omitempty"`
	Color       *string    `json:"color,omitempty"`
	Coordinates *[]float32 `json:"coordinates,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *time.Time `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *int       `json:"id,omitempty"`
	IsDeleted   *bool      `json:"is_deleted,omitempty"`
	Latitude    *float32   `json:"latitude,omitempty"`
	LocationId  *int       `json:"location_id,omitempty"`
	Longitude   *float32   `json:"longitude,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Place       *Place     `json:"place,omitempty"`
	PlaceId     *string    `json:"place_id,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// SiteRequest defines model for SiteRequest.
type SiteRequest struct {
	AccountId   *int       `json:"account_id,omitempty"`
	Address     *string    `json:"address,omitempty"`
	Color       *string    `json:"color,omitempty"`
	Coordinates *[]float32 `json:"coordinates,omitempty"`
	Description *string    `json:"description,omitempty"`
	Latitude    *float32   `json:"latitude,omitempty"`
	LocationId  *int       `json:"location_id,omitempty"`
	Longitude   *float32   `json:"longitude,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Place       *Place     `json:"place,omitempty"`
	PlaceId     *string    `json:"place_id,omitempty"`
}

// Time defines model for Time.
type Time struct {
	// AccountId The account id
	AccountId *int `json:"account_id,omitempty"`

	// AlertType The type of alert for this time
	AlertType *int `json:"alert_type,omitempty"`

	// CashTips Any cash tips reported for the shift.
	// Note: the tips feature is required to see and use this field.
	CashTips *string `json:"cash_tips"`

	// CreatedAt When the time was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatorId The user that created the time.
	CreatorId *int `json:"creator_id,omitempty"`

	// EndTime The end time
	EndTime *time.Time `json:"end_time,omitempty"`

	// HourlyRate The base hourly rate for this time.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// Id The time id
	Id *int `json:"id,omitempty"`

	// IsAlerted If alert_type > 0
	IsAlerted *bool `json:"is_alerted,omitempty"`

	// IsApproved If the time is approved
	IsApproved *bool `json:"is_approved,omitempty"`

	// Length The length of the time in hours.
	Length *float32 `json:"length,omitempty"`

	// LocationId Location the time belongs to. 0 if unassigned.
	LocationId *int `json:"location_id,omitempty"`

	// ModifiedBy The user that modified the time
	ModifiedBy *int `json:"modified_by,omitempty"`

	// Notes Notes for a time
	Notes *string `json:"notes,omitempty"`

	// PositionId Position the time belongs to. 0 if unassigned.
	PositionId *int `json:"position_id,omitempty"`

	// RoundedEndTime The rounded end time. If rounding is not enabled this field will not be present.
	RoundedEndTime *time.Time `json:"rounded_end_time,omitempty"`

	// RoundedLength The rounded length calculated from the rounded_start_time and rounded_end_time. If rounding is not enabled this field will not be present.
	RoundedLength *float32 `json:"rounded_length,omitempty"`

	// RoundedStartTime The rounded start time. If rounding is not enabled this field will not be present.
	RoundedStartTime *time.Time `json:"rounded_start_time,omitempty"`

	// ShiftId A shift tied to this time. 0 if unassigned.
	ShiftId *int `json:"shift_id,omitempty"`

	// SiteId Site the time belongs to. 0 if unassigned.
	SiteId *int `json:"site_id,omitempty"`

	// SplitTime If the time crosses payroll periods, when to split it
	SplitTime *time.Time `json:"split_time,omitempty"`

	// StartTime The start time
	StartTime *time.Time `json:"start_time,omitempty"`

	// SyncHash The quickbooks sync hash
	SyncHash *string `json:"sync_hash,omitempty"`

	// SyncId The quickbooks sync id
	SyncId *string `json:"sync_id,omitempty"`

	// UpdatedAt When the time was updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserId The user assigned to the time.
	UserId *int `json:"user_id,omitempty"`
}

// TimeRequest defines model for TimeRequest.
type TimeRequest struct {
	// CashTips The amount of cash tips reported for the time entry.
	CashTips *string `json:"cash_tips,omitempty"`

	// EndTime The end time
	EndTime *time.Time `json:"end_time,omitempty"`

	// IsApproved If the time is approved
	IsApproved *bool `json:"is_approved,omitempty"`

	// LocationId Location the time belongs to. 0 if unassigned.
	LocationId *int `json:"location_id,omitempty"`

	// Notes Notes for a time
	Notes *string `json:"notes,omitempty"`

	// PositionId Position the time belongs to. 0 if unassigned.
	PositionId *int `json:"position_id,omitempty"`

	// RoundedEndTime The rounded end time. If rounding is not enabled this field will not be present.
	RoundedEndTime *time.Time `json:"rounded_end_time,omitempty"`

	// RoundedStartTime The rounded start time. If rounding is not enabled this field will not be present.
	RoundedStartTime *time.Time `json:"rounded_start_time,omitempty"`

	// ShiftId A shift tied to this time. 0 if unassigned.
	ShiftId *int `json:"shift_id,omitempty"`

	// SiteId Site the time belongs to. 0 if unassigned.
	SiteId *int `json:"site_id,omitempty"`

	// StartTime The start time. For accounts with Check payroll onboarded, time must not be past the end of the current pay period
	StartTime *time.Time `json:"start_time,omitempty"`

	// UserId The user assigned to the times.
	UserId *int `json:"user_id,omitempty"`
}

// Timezone defines model for Timezone.
type Timezone struct {
	Name string `json:"name"`
}

// UpdateUserRequest defines model for UpdateUserRequest.
type UpdateUserRequest struct {
	// AccountId ID of the primary account for this user.
	AccountId *int `json:"account_id,omitempty"`

	// Activated Whether the manager has activated this user.
	Activated *bool `json:"activated,omitempty"`

	// Email The email address of this user.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeCode The user's employee code. This code can be used to clock in instead of the user's email address, or it can be used to help map users in When I Work to other services.
	EmployeeCode *string `json:"employee_code,omitempty"`

	// FirstName The first name of this user.
	FirstName *string `json:"first_name,omitempty"`

	// HourlyRate The base hourly rate for this user. The user can have additional wages based on the position they are working at the time. There is no currency attached, so customers are expected to input correct values for their currency or do their own conversion from USD.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// HoursMax The max hours that this user prefers to work. A manager may still schedule the user beyond this value.
	HoursMax *float32 `json:"hours_max,omitempty"`

	// HoursPreferred The preferred number of hours for this user to work.
	HoursPreferred *float32 `json:"hours_preferred,omitempty"`

	// Id Unique identifier for the user.
	Id *int `json:"id,omitempty"`

	// IsDeleted Whether the user has been deleted.
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// IsHidden Whether the user has been hidden from the scheduler.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPayroll Whether the user has access to payroll. (Only available for managers and supervisors.)
	IsPayroll *bool `json:"is_payroll,omitempty"`

	// IsPrivate Whether the user has privacy enabled, which will hide their contact details from other employees. Supervisors+ can not hide their email/phone from other employees.
	IsPrivate *bool `json:"is_private,omitempty"`

	// IsTrusted Whether the user can edit their own timesheet.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// LastLogin The date and time when this user last logged in.
	LastLogin *time.Time `json:"last_login,omitempty"`

	// LastName The last name of this user.
	LastName *string `json:"last_name,omitempty"`

	// Locations An array of location IDs to be applied to this user.
	Locations *[]int `json:"locations,omitempty"`

	// LoginId Unique identifier for the login belonging to the user.
	LoginId *int `json:"login_id,omitempty"`

	// Notes Notes about this user. Visible only to supervisors+.
	Notes *string `json:"notes,omitempty"`

	// PhoneNumber The phone number of this user.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Positions An array of position IDs to be assigned to this user.
	Positions *[]int `json:"positions,omitempty"`

	// Reactivate Whether to reactivate a previously deleted user.
	Reactivate *bool `json:"reactivate,omitempty"`

	// Role The user's role.
	Role *UpdateUserRequestRole `json:"role,omitempty"`

	// Type A bitwise flag representing additional wage options.
	Type *UpdateUserRequestType `json:"type,omitempty"`
}

// UpdateUserRequestRole The user's role.
type UpdateUserRequestRole string

// UpdateUserRequestType A bitwise flag representing additional wage options.
type UpdateUserRequestType int

// User defines model for User.
type User struct {
	// AccountId ID of the primary account for this user.
	AccountId *int `json:"account_id,omitempty"`

	// Activated Whether the manager has activated this user.
	Activated *bool `json:"activated,omitempty"`

	// Email The email address of this user.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeCode The user's employee code. This code can be used to clock in instead of the user's email address, or it can be used to help map users in When I Work to other services.
	EmployeeCode *string `json:"employee_code,omitempty"`

	// FirstName The first name of this user.
	FirstName *string `json:"first_name,omitempty"`

	// HourlyRate The base hourly rate for this user. The user can have additional wages based on the position they are working at the time. There is no currency attached, so customers are expected to input correct values for their currency or do their own conversion from USD.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// HoursMax The max hours that this user prefers to work. A manager may still schedule the user beyond this value.
	HoursMax *float32 `json:"hours_max,omitempty"`

	// HoursPreferred The preferred number of hours for this user to work.
	HoursPreferred *float32 `json:"hours_preferred,omitempty"`

	// Id Unique identifier for the user.
	Id *int `json:"id,omitempty"`

	// IsDeleted Whether the user has been deleted.
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// IsHidden Whether the user has been hidden from the scheduler.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPayroll Whether the user has access to payroll. (Only available for managers and supervisors.)
	IsPayroll *bool `json:"is_payroll,omitempty"`

	// IsPrivate Whether the user has privacy enabled, which will hide their contact details from other employees. Supervisors+ can not hide their email/phone from other employees.
	IsPrivate *bool `json:"is_private,omitempty"`

	// IsTrusted Whether the user can edit their own timesheet.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// LastLogin The date and time when this user last logged in.
	LastLogin *time.Time `json:"last_login,omitempty"`

	// LastName The last name of this user.
	LastName *string `json:"last_name,omitempty"`

	// Locations An array of location IDs to be applied to this user.
	Locations *[]int `json:"locations,omitempty"`

	// LoginId Unique identifier for the login belonging to the user.
	LoginId *int `json:"login_id,omitempty"`

	// Notes Notes about this user. Visible only to supervisors+.
	Notes *string `json:"notes,omitempty"`

	// PhoneNumber The phone number of this user.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Positions An array of position IDs to be assigned to this user.
	Positions *[]int `json:"positions,omitempty"`

	// Role The user's role.
	Role *UserRole `json:"role,omitempty"`

	// Type A bitwise flag representing additional wage options.
	Type *UserType `json:"type,omitempty"`
}

// UserRole The user's role.
type UserRole string

// UserType A bitwise flag representing additional wage options.
type UserType int

// UserRequest defines model for UserRequest.
type UserRequest struct {
	// AccountId ID of the primary account for this user.
	AccountId *int `json:"account_id,omitempty"`

	// Activated Whether the manager has activated this user.
	Activated *bool `json:"activated,omitempty"`

	// Email The email address of this user.
	Email *openapi_types.Email `json:"email,omitempty"`

	// EmployeeCode The user's employee code. This code can be used to clock in instead of the user's email address, or it can be used to help map users in When I Work to other services.
	EmployeeCode *string `json:"employee_code,omitempty"`

	// FirstName The first name of this user.
	FirstName *string `json:"first_name,omitempty"`

	// HourlyRate The base hourly rate for this user. The user can have additional wages based on the position they are working at the time. There is no currency attached, so customers are expected to input correct values for their currency or do their own conversion from USD.
	HourlyRate *float32 `json:"hourly_rate,omitempty"`

	// HoursMax The max hours that this user prefers to work. A manager may still schedule the user beyond this value.
	HoursMax *float32 `json:"hours_max,omitempty"`

	// HoursPreferred The preferred number of hours for this user to work.
	HoursPreferred *float32 `json:"hours_preferred,omitempty"`

	// Id Unique identifier for the user.
	Id *int `json:"id,omitempty"`

	// Invite Whether an invite should be sent upon user creation. When missing or not false, an invite is sent by default
	Invite *bool `json:"invite,omitempty"`

	// IsDeleted Whether the user has been deleted.
	IsDeleted *bool `json:"is_deleted,omitempty"`

	// IsHidden Whether the user has been hidden from the scheduler.
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPayroll Whether the user has access to payroll. (Only available for managers and supervisors.)
	IsPayroll *bool `json:"is_payroll,omitempty"`

	// IsPrivate Whether the user has privacy enabled, which will hide their contact details from other employees. Supervisors+ can not hide their email/phone from other employees.
	IsPrivate *bool `json:"is_private,omitempty"`

	// IsTrusted Whether the user can edit their own timesheet.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// LastLogin The date and time when this user last logged in.
	LastLogin *time.Time `json:"last_login,omitempty"`

	// LastName The last name of this user.
	LastName *string `json:"last_name,omitempty"`

	// Locations An array of location IDs to be applied to this user.
	Locations *[]int `json:"locations,omitempty"`

	// LoginId Unique identifier for the login belonging to the user.
	LoginId *int `json:"login_id,omitempty"`

	// Notes Notes about this user. Visible only to supervisors+.
	Notes *string `json:"notes,omitempty"`

	// PhoneNumber The phone number of this user.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Positions An array of position IDs to be assigned to this user.
	Positions *[]int `json:"positions,omitempty"`

	// Role The user's role.
	Role *UserRequestRole `json:"role,omitempty"`

	// Type A bitwise flag representing additional wage options.
	Type *UserRequestType `json:"type,omitempty"`
}

// UserRequestRole The user's role.
type UserRequestRole string

// UserRequestType A bitwise flag representing additional wage options.
type UserRequestType int

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// WKey The developer key
	WKey string `json:"W-Key"`

	// WUserID The user id
	WUserID *string `json:"W-UserID,omitempty"`
}

// ListShiftsParams defines parameters for ListShifts.
type ListShiftsParams struct {
	// UserId The user id to filter by
	UserId *int `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Start The start of the filter range.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The end of the filter range.
	End *string `form:"end,omitempty" json:"end,omitempty"`

	// Unpublished Whether or not to include unpublished shifts. Requires supervisor rights.
	Unpublished *bool `form:"unpublished,omitempty" json:"unpublished,omitempty"`

	// IncludeOpen Whether or not to include open shifts from the user's assigned Schedules.
	IncludeOpen *bool `form:"include_open,omitempty" json:"include_open,omitempty"`

	// IncludeOnlyopen Whether or not to include only open shifts from the user's assigned Schedules.
	IncludeOnlyopen *bool `form:"include_onlyopen,omitempty" json:"include_onlyopen,omitempty"`

	// IncludeAllopen Whether to include open shifts across All Schedules. Requires "Manager or Admin access" level.
	IncludeAllopen *bool `form:"include_allopen,omitempty" json:"include_allopen,omitempty"`

	// Deleted Whether to include a list of shift IDs ("deleted_ids") that were deleted during the passed time window.
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`

	// IncludeSwaps Whether or not to include swap requests.
	IncludeSwaps *bool `form:"include_swaps,omitempty" json:"include_swaps,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// AllLocations Whether to include data from all locations. Shifts are marked as "readonly" if not a manager user.
	AllLocations *bool `form:"all_locations,omitempty" json:"all_locations,omitempty"`

	// LocationId One or more location IDs by which to limit results
	LocationId *string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// ShiftSort True to sort results by user_id, false to sort by shift time. Missing for default sort
	ShiftSort *bool `form:"shift_sort,omitempty" json:"shift_sort,omitempty"`

	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`

	// TrimOpenshifts Setting to true will work w/ the Allow Partial Openshifts feature to display trimmed start/end times for
	// users that can take a conflicting openshift based on the account settings.
	TrimOpenshifts *bool `form:"trim_openshifts,omitempty" json:"trim_openshifts,omitempty"`

	// LimitByRules Setting to true will work w/ the Scheduling Rules feature to only return OpenShifts that the requester is eligible for
	// according to the scheduling rules settings for the account.
	LimitByRules *bool `form:"limit_by_rules,omitempty" json:"limit_by_rules,omitempty"`

	// WUserID The user to select account context for
	WUserID *string `json:"W-UserID,omitempty"`
}

// BulkUpdateShiftsParams defines parameters for BulkUpdateShifts.
type BulkUpdateShiftsParams struct {
	// AssignOpenshiftInstances When set to true, any multiple instance openshifts that are being assigned will assign only one openshift off the stack rather than the entire stack.
	AssignOpenshiftInstances *bool `form:"assign_openshift_instances,omitempty" json:"assign_openshift_instances,omitempty"`
}

// ListEligibleUsersForOpenShiftParams defines parameters for ListEligibleUsersForOpenShift.
type ListEligibleUsersForOpenShiftParams struct {
	// Id The ID of the shift
	Id *int `form:"id,omitempty" json:"id,omitempty"`

	// Start Start time of the potential shift (required if Shift ID not present)
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End time of the potential shift (required if Shift ID not present)
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// PositionId Position ID of the potential shift (required if Shift ID not present)
	PositionId *string `form:"position_id,omitempty" json:"position_id,omitempty"`

	// LocationId Location ID of the potential shift (required if Shift ID not present)
	LocationId *string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// IsShared Is the shift a shared OpenShift
	IsShared *bool `form:"is_shared,omitempty" json:"is_shared,omitempty"`
}

// DeleteShiftParams defines parameters for DeleteShift.
type DeleteShiftParams struct {
	// Message Used to notify the shift's assignee that their shift has been deleted. Your message will be added to the notification email. If you want to send the notification email without a message, simply send a single space. Must be URL encoded.
	Message *string `form:"message,omitempty" json:"message,omitempty"`

	// Chain Only applies to repeating shifts. Any value will delete the shift and all shifts that come after it on the chain.
	Chain *string `form:"chain,omitempty" json:"chain,omitempty"`
}

// GetShiftParams defines parameters for GetShift.
type GetShiftParams struct {
	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`
}

// UpdateShiftJSONBody defines parameters for UpdateShift.
type UpdateShiftJSONBody struct {
	union json.RawMessage
}

// UpdateShiftParams defines parameters for UpdateShift.
type UpdateShiftParams struct {
	// IncludeRepeatingShiftsTo End date to include repeating shifts in series, if applicable
	IncludeRepeatingShiftsTo *time.Time `form:"include_repeating_shifts_to,omitempty" json:"include_repeating_shifts_to,omitempty"`
}

// UpdateShiftJSONBody1 defines parameters for UpdateShift.
type UpdateShiftJSONBody1 = []Shift

// GetShiftHistoryParams defines parameters for GetShiftHistory.
type GetShiftHistoryParams struct {
	// IncludeDeleted Flag to indicate if you want to search for a deleted shift's history (off by default)
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// GetSwapUsersParams defines parameters for GetSwapUsers.
type GetSwapUsersParams struct {
	// Id The ID of the shift being dropped
	Id *int `form:"id,omitempty" json:"id,omitempty"`

	// Count Flag to indicate if only a count of eligible takers should be returned
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// IdsOnly Flag to indicate if only the IDs of the eligible takers should be returned
	IdsOnly *int `form:"ids_only,omitempty" json:"ids_only,omitempty"`
}

// ListSitesParams defines parameters for ListSites.
type ListSitesParams struct {
	// IncludeDeleted Include deleted sites
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// ListTimesParams defines parameters for ListTimes.
type ListTimesParams struct {
	// Start The start of the filter range.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The end of the filter range.
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// UserId List of user ids to filter on
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// OnlyOpen Return only times without an end time
	OnlyOpen *bool `form:"only_open,omitempty" json:"only_open,omitempty"`

	// UpdatedAt Only return times that have been updated since the provided timestamp.
	UpdatedAt *time.Time `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// OverwriteWithRounded Flag to overwrite the start/end/length values with their rounded counterparts (if account setting is enabled)
	OverwriteWithRounded *int `form:"overwrite_with_rounded,omitempty" json:"overwrite_with_rounded,omitempty"`

	// IncludePaidBreakNote Returns the note for a Shift Break Paid Record. Deprecated - please refer to the break attestation docs [here](#tag/Break-Attestation)
	IncludePaidBreakNote *bool `form:"include_paid_break_note,omitempty" json:"include_paid_break_note,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// LocationId One or more location IDs by which to limit results
	LocationId *[]int `form:"location_id,omitempty" json:"location_id,omitempty"`

	// ShowPending Include pending users in results. Defaults to true.
	ShowPending *bool `form:"show_pending,omitempty" json:"show_pending,omitempty"`

	// OnlyPending Include ONLY pending users in results. Defaults to false.
	OnlyPending *bool `form:"only_pending,omitempty" json:"only_pending,omitempty"`

	// ShowDeleted Include deleted users in results. Defaults to false.
	ShowDeleted *bool `form:"show_deleted,omitempty" json:"show_deleted,omitempty"`

	// OnlyDeleted Only include deleted/archived users in results. Defaults to false.
	OnlyDeleted *bool `form:"only_deleted,omitempty" json:"only_deleted,omitempty"`

	// Search Optional string to search by in users first name, last name, or email.
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// CreateOrUpdateUserAvatarParams defines parameters for CreateOrUpdateUserAvatar.
type CreateOrUpdateUserAvatarParams struct {
	// ContentType The type of content being uploaded
	ContentType string `json:"content-type"`
}

// BulkCreateUsersJSONBody defines parameters for BulkCreateUsers.
type BulkCreateUsersJSONBody = []UserRequest

// InviteSingleUserJSONBody defines parameters for InviteSingleUser.
type InviteSingleUserJSONBody struct {
	// Message An optional message to include in the email invite.
	Message *string `json:"message,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// DeletedShifts Indicates whether or not to delete this user's future shifts. If not deleted, those shifts will be moved to Open Shifts.
	DeletedShifts *bool `form:"deleted_shifts,omitempty" json:"deleted_shifts,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// BulkUpdateShiftsJSONRequestBody defines body for BulkUpdateShifts for application/json ContentType.
type BulkUpdateShiftsJSONRequestBody = BulkEditShiftRequest

// NotifyShiftsJSONRequestBody defines body for NotifyShifts for application/json ContentType.
type NotifyShiftsJSONRequestBody = ShiftNotifyRequest

// NotifySingleShiftJSONRequestBody defines body for NotifySingleShift for application/json ContentType.
type NotifySingleShiftJSONRequestBody = SingleShiftNotifyRequest

// PublishShiftsJSONRequestBody defines body for PublishShifts for application/json ContentType.
type PublishShiftsJSONRequestBody = ShiftPublish

// UnassignShiftsJSONRequestBody defines body for UnassignShifts for application/json ContentType.
type UnassignShiftsJSONRequestBody = ShiftUnassignRequest

// UnpublishShiftsJSONRequestBody defines body for UnpublishShifts for application/json ContentType.
type UnpublishShiftsJSONRequestBody = ShiftPublish

// AssignUsersToOpenShiftJSONRequestBody defines body for AssignUsersToOpenShift for application/json ContentType.
type AssignUsersToOpenShiftJSONRequestBody = ShiftAssignRequest

// UpdateShiftJSONRequestBody defines body for UpdateShift for application/json ContentType.
type UpdateShiftJSONRequestBody UpdateShiftJSONBody

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = SiteRequest

// UpdateSiteJSONRequestBody defines body for UpdateSite for application/json ContentType.
type UpdateSiteJSONRequestBody = SiteRequest

// CreateTimeJSONRequestBody defines body for CreateTime for application/json ContentType.
type CreateTimeJSONRequestBody = TimeRequest

// UpdateTimeJSONRequestBody defines body for UpdateTime for application/json ContentType.
type UpdateTimeJSONRequestBody = TimeRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserRequest

// BulkCreateUsersJSONRequestBody defines body for BulkCreateUsers for application/json ContentType.
type BulkCreateUsersJSONRequestBody = BulkCreateUsersJSONBody

// InviteUsersJSONRequestBody defines body for InviteUsers for application/json ContentType.
type InviteUsersJSONRequestBody = InviteUserRequest

// InviteSingleUserJSONRequestBody defines body for InviteSingleUser for application/json ContentType.
type InviteSingleUserJSONRequestBody InviteSingleUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListShifts request
	ListShifts(ctx context.Context, params *ListShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateShiftsWithBody request with any body
	BulkUpdateShiftsWithBody(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateShifts(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEligibleUsersForOpenShift request
	ListEligibleUsersForOpenShift(ctx context.Context, params *ListEligibleUsersForOpenShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyShiftsWithBody request with any body
	NotifyShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotifyShifts(ctx context.Context, body NotifyShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifySingleShiftWithBody request with any body
	NotifySingleShiftWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotifySingleShift(ctx context.Context, id int, body NotifySingleShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishShiftsWithBody request with any body
	PublishShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishShifts(ctx context.Context, body PublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignShiftsWithBody request with any body
	UnassignShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnassignShifts(ctx context.Context, body UnassignShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpublishShiftsWithBody request with any body
	UnpublishShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnpublishShifts(ctx context.Context, body UnpublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShift request
	DeleteShift(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShift request
	GetShift(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUsersToOpenShiftWithBody request with any body
	AssignUsersToOpenShiftWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignUsersToOpenShift(ctx context.Context, id int, body AssignUsersToOpenShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShiftWithBody request with any body
	UpdateShiftWithBody(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShift(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShiftHistory request
	GetShiftHistory(ctx context.Context, id int, params *GetShiftHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwapUsers request
	GetSwapUsers(ctx context.Context, id int, params *GetSwapUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSites request
	ListSites(ctx context.Context, params *ListSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSite request
	DeleteSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSiteWithBody request with any body
	UpdateSiteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSite(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTimes request
	ListTimes(ctx context.Context, params *ListTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTimeWithBody request with any body
	CreateTimeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTime(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTime request
	DeleteTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTime request
	GetTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTimeWithBody request with any body
	UpdateTimeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTime(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateUserAvatarWithBody request with any body
	CreateOrUpdateUserAvatarWithBody(ctx context.Context, id int, params *CreateOrUpdateUserAvatarParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateUsersWithBody request with any body
	BulkCreateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateUsers(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUsersWithBody request with any body
	InviteUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUsers(ctx context.Context, body InviteUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteSingleUserWithBody request with any body
	InviteSingleUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteSingleUser(ctx context.Context, id int, body InviteSingleUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, id int, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListShifts(ctx context.Context, params *ListShiftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListShiftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateShiftsWithBody(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateShiftsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateShifts(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateShiftsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEligibleUsersForOpenShift(ctx context.Context, params *ListEligibleUsersForOpenShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEligibleUsersForOpenShiftRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyShiftsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyShifts(ctx context.Context, body NotifyShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyShiftsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifySingleShiftWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifySingleShiftRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifySingleShift(ctx context.Context, id int, body NotifySingleShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifySingleShiftRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishShiftsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishShifts(ctx context.Context, body PublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishShiftsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignShiftsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignShifts(ctx context.Context, body UnassignShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignShiftsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishShiftsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpublishShiftsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishShifts(ctx context.Context, body UnpublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpublishShiftsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShift(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShiftRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShift(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUsersToOpenShiftWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUsersToOpenShiftRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUsersToOpenShift(ctx context.Context, id int, body AssignUsersToOpenShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUsersToOpenShiftRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShiftWithBody(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShiftRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShift(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShiftRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShiftHistory(ctx context.Context, id int, params *GetShiftHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftHistoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapUsers(ctx context.Context, id int, params *GetSwapUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSites(ctx context.Context, params *ListSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSiteWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSiteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSite(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSiteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTimes(ctx context.Context, params *ListTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTimesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTimeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTime(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTimeWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTime(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateUserAvatarWithBody(ctx context.Context, id int, params *CreateOrUpdateUserAvatarParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateUserAvatarRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateUsers(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsers(ctx context.Context, body InviteUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteSingleUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteSingleUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteSingleUser(ctx context.Context, id int, body InviteSingleUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteSingleUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, id int, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-Key", runtime.ParamLocationHeader, params.WKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("W-Key", headerParam0)

		if params.WUserID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam1)
		}

	}

	return req, nil
}

// NewListShiftsRequest generates requests for ListShifts
func NewListShiftsRequest(server string, params *ListShiftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unpublished != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unpublished", runtime.ParamLocationQuery, *params.Unpublished); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOpen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_open", runtime.ParamLocationQuery, *params.IncludeOpen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOnlyopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_onlyopen", runtime.ParamLocationQuery, *params.IncludeOnlyopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAllopen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_allopen", runtime.ParamLocationQuery, *params.IncludeAllopen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSwaps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_swaps", runtime.ParamLocationQuery, *params.IncludeSwaps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_locations", runtime.ParamLocationQuery, *params.AllLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShiftSort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_sort", runtime.ParamLocationQuery, *params.ShiftSort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrimOpenshifts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trim_openshifts", runtime.ParamLocationQuery, *params.TrimOpenshifts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitByRules != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_by_rules", runtime.ParamLocationQuery, *params.LimitByRules); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.WUserID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "W-UserID", runtime.ParamLocationHeader, *params.WUserID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("W-UserID", headerParam0)
		}

	}

	return req, nil
}

// NewBulkUpdateShiftsRequest calls the generic BulkUpdateShifts builder with application/json body
func NewBulkUpdateShiftsRequest(server string, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateShiftsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBulkUpdateShiftsRequestWithBody generates requests for BulkUpdateShifts with any type of body
func NewBulkUpdateShiftsRequestWithBody(server string, params *BulkUpdateShiftsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssignOpenshiftInstances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assign_openshift_instances", runtime.ParamLocationQuery, *params.AssignOpenshiftInstances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEligibleUsersForOpenShiftRequest generates requests for ListEligibleUsersForOpenShift
func NewListEligibleUsersForOpenShiftRequest(server string, params *ListEligibleUsersForOpenShiftParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/eligible")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position_id", runtime.ParamLocationQuery, *params.PositionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsShared != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_shared", runtime.ParamLocationQuery, *params.IsShared); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotifyShiftsRequest calls the generic NotifyShifts builder with application/json body
func NewNotifyShiftsRequest(server string, body NotifyShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotifyShiftsRequestWithBody(server, "application/json", bodyReader)
}

// NewNotifyShiftsRequestWithBody generates requests for NotifyShifts with any type of body
func NewNotifyShiftsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/notify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotifySingleShiftRequest calls the generic NotifySingleShift builder with application/json body
func NewNotifySingleShiftRequest(server string, id int, body NotifySingleShiftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotifySingleShiftRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNotifySingleShiftRequestWithBody generates requests for NotifySingleShift with any type of body
func NewNotifySingleShiftRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/notify/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishShiftsRequest calls the generic PublishShifts builder with application/json body
func NewPublishShiftsRequest(server string, body PublishShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishShiftsRequestWithBody(server, "application/json", bodyReader)
}

// NewPublishShiftsRequestWithBody generates requests for PublishShifts with any type of body
func NewPublishShiftsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/publish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignShiftsRequest calls the generic UnassignShifts builder with application/json body
func NewUnassignShiftsRequest(server string, body UnassignShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnassignShiftsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnassignShiftsRequestWithBody generates requests for UnassignShifts with any type of body
func NewUnassignShiftsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/unassign")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnpublishShiftsRequest calls the generic UnpublishShifts builder with application/json body
func NewUnpublishShiftsRequest(server string, body UnpublishShiftsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnpublishShiftsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnpublishShiftsRequestWithBody generates requests for UnpublishShifts with any type of body
func NewUnpublishShiftsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/unpublish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShiftRequest generates requests for DeleteShift
func NewDeleteShiftRequest(server string, id int, params *DeleteShiftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Chain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShiftRequest generates requests for GetShift
func NewGetShiftRequest(server string, id int, params *GetShiftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUsersToOpenShiftRequest calls the generic AssignUsersToOpenShift builder with application/json body
func NewAssignUsersToOpenShiftRequest(server string, id int, body AssignUsersToOpenShiftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignUsersToOpenShiftRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignUsersToOpenShiftRequestWithBody generates requests for AssignUsersToOpenShift with any type of body
func NewAssignUsersToOpenShiftRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateShiftRequest calls the generic UpdateShift builder with application/json body
func NewUpdateShiftRequest(server string, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShiftRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateShiftRequestWithBody generates requests for UpdateShift with any type of body
func NewUpdateShiftRequestWithBody(server string, id int, params *UpdateShiftParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeRepeatingShiftsTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_repeating_shifts_to", runtime.ParamLocationQuery, *params.IncludeRepeatingShiftsTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShiftHistoryRequest generates requests for GetShiftHistory
func NewGetShiftHistoryRequest(server string, id int, params *GetShiftHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapUsersRequest generates requests for GetSwapUsers
func NewGetSwapUsersRequest(server string, id int, params *GetSwapUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/shifts/%s/swapusers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids_only", runtime.ParamLocationQuery, *params.IdsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSitesRequest generates requests for ListSites
func NewListSitesRequest(server string, params *ListSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteRequest generates requests for DeleteSite
func NewDeleteSiteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSiteRequest calls the generic UpdateSite builder with application/json body
func NewUpdateSiteRequest(server string, id int, body UpdateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSiteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSiteRequestWithBody generates requests for UpdateSite with any type of body
func NewUpdateSiteRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTimesRequest generates requests for ListTimes
func NewListTimesRequest(server string, params *ListTimesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyOpen != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_open", runtime.ParamLocationQuery, *params.OnlyOpen); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OverwriteWithRounded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite_with_rounded", runtime.ParamLocationQuery, *params.OverwriteWithRounded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePaidBreakNote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_paid_break_note", runtime.ParamLocationQuery, *params.IncludePaidBreakNote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTimeRequest calls the generic CreateTime builder with application/json body
func NewCreateTimeRequest(server string, body CreateTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTimeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTimeRequestWithBody generates requests for CreateTime with any type of body
func NewCreateTimeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTimeRequest generates requests for DeleteTime
func NewDeleteTimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimeRequest generates requests for GetTime
func NewGetTimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTimeRequest calls the generic UpdateTime builder with application/json body
func NewUpdateTimeRequest(server string, id int, body UpdateTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTimeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTimeRequestWithBody generates requests for UpdateTime with any type of body
func NewUpdateTimeRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowPending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_pending", runtime.ParamLocationQuery, *params.ShowPending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyPending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_pending", runtime.ParamLocationQuery, *params.OnlyPending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_deleted", runtime.ParamLocationQuery, *params.ShowDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_deleted", runtime.ParamLocationQuery, *params.OnlyDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOrUpdateUserAvatarRequestWithBody generates requests for CreateOrUpdateUserAvatar with any type of body
func NewCreateOrUpdateUserAvatarRequestWithBody(server string, id int, params *CreateOrUpdateUserAvatarParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/avatar/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "content-type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("content-type", headerParam0)

	}

	return req, nil
}

// NewBulkCreateUsersRequest calls the generic BulkCreateUsers builder with application/json body
func NewBulkCreateUsersRequest(server string, body BulkCreateUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateUsersRequestWithBody generates requests for BulkCreateUsers with any type of body
func NewBulkCreateUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/bulkupdate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteUsersRequest calls the generic InviteUsers builder with application/json body
func NewInviteUsersRequest(server string, body InviteUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUsersRequestWithBody generates requests for InviteUsers with any type of body
func NewInviteUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteSingleUserRequest calls the generic InviteSingleUser builder with application/json body
func NewInviteSingleUserRequest(server string, id int, body InviteSingleUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteSingleUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewInviteSingleUserRequestWithBody generates requests for InviteSingleUser with any type of body
func NewInviteSingleUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/invite/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, id int, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeletedShifts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_shifts", runtime.ParamLocationQuery, *params.DeletedShifts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id int, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// ListShiftsWithResponse request
	ListShiftsWithResponse(ctx context.Context, params *ListShiftsParams, reqEditors ...RequestEditorFn) (*ListShiftsResponse, error)

	// BulkUpdateShiftsWithBodyWithResponse request with any body
	BulkUpdateShiftsWithBodyWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error)

	BulkUpdateShiftsWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error)

	// ListEligibleUsersForOpenShiftWithResponse request
	ListEligibleUsersForOpenShiftWithResponse(ctx context.Context, params *ListEligibleUsersForOpenShiftParams, reqEditors ...RequestEditorFn) (*ListEligibleUsersForOpenShiftResponse, error)

	// NotifyShiftsWithBodyWithResponse request with any body
	NotifyShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifyShiftsResponse, error)

	NotifyShiftsWithResponse(ctx context.Context, body NotifyShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifyShiftsResponse, error)

	// NotifySingleShiftWithBodyWithResponse request with any body
	NotifySingleShiftWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifySingleShiftResponse, error)

	NotifySingleShiftWithResponse(ctx context.Context, id int, body NotifySingleShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifySingleShiftResponse, error)

	// PublishShiftsWithBodyWithResponse request with any body
	PublishShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishShiftsResponse, error)

	PublishShiftsWithResponse(ctx context.Context, body PublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishShiftsResponse, error)

	// UnassignShiftsWithBodyWithResponse request with any body
	UnassignShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnassignShiftsResponse, error)

	UnassignShiftsWithResponse(ctx context.Context, body UnassignShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnassignShiftsResponse, error)

	// UnpublishShiftsWithBodyWithResponse request with any body
	UnpublishShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnpublishShiftsResponse, error)

	UnpublishShiftsWithResponse(ctx context.Context, body UnpublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnpublishShiftsResponse, error)

	// DeleteShiftWithResponse request
	DeleteShiftWithResponse(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*DeleteShiftResponse, error)

	// GetShiftWithResponse request
	GetShiftWithResponse(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*GetShiftResponse, error)

	// AssignUsersToOpenShiftWithBodyWithResponse request with any body
	AssignUsersToOpenShiftWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUsersToOpenShiftResponse, error)

	AssignUsersToOpenShiftWithResponse(ctx context.Context, id int, body AssignUsersToOpenShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUsersToOpenShiftResponse, error)

	// UpdateShiftWithBodyWithResponse request with any body
	UpdateShiftWithBodyWithResponse(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error)

	UpdateShiftWithResponse(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error)

	// GetShiftHistoryWithResponse request
	GetShiftHistoryWithResponse(ctx context.Context, id int, params *GetShiftHistoryParams, reqEditors ...RequestEditorFn) (*GetShiftHistoryResponse, error)

	// GetSwapUsersWithResponse request
	GetSwapUsersWithResponse(ctx context.Context, id int, params *GetSwapUsersParams, reqEditors ...RequestEditorFn) (*GetSwapUsersResponse, error)

	// ListSitesWithResponse request
	ListSitesWithResponse(ctx context.Context, params *ListSitesParams, reqEditors ...RequestEditorFn) (*ListSitesResponse, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	// DeleteSiteWithResponse request
	DeleteSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSiteResponse, error)

	// UpdateSiteWithBodyWithResponse request with any body
	UpdateSiteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error)

	UpdateSiteWithResponse(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error)

	// ListTimesWithResponse request
	ListTimesWithResponse(ctx context.Context, params *ListTimesParams, reqEditors ...RequestEditorFn) (*ListTimesResponse, error)

	// CreateTimeWithBodyWithResponse request with any body
	CreateTimeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error)

	CreateTimeWithResponse(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error)

	// DeleteTimeWithResponse request
	DeleteTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTimeResponse, error)

	// GetTimeWithResponse request
	GetTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTimeResponse, error)

	// UpdateTimeWithBodyWithResponse request with any body
	UpdateTimeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error)

	UpdateTimeWithResponse(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// CreateOrUpdateUserAvatarWithBodyWithResponse request with any body
	CreateOrUpdateUserAvatarWithBodyWithResponse(ctx context.Context, id int, params *CreateOrUpdateUserAvatarParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateUserAvatarResponse, error)

	// BulkCreateUsersWithBodyWithResponse request with any body
	BulkCreateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error)

	BulkCreateUsersWithResponse(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error)

	// InviteUsersWithBodyWithResponse request with any body
	InviteUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersResponse, error)

	InviteUsersWithResponse(ctx context.Context, body InviteUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersResponse, error)

	// InviteSingleUserWithBodyWithResponse request with any body
	InviteSingleUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteSingleUserResponse, error)

	InviteSingleUserWithResponse(ctx context.Context, id int, body InviteSingleUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteSingleUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, id int, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts *[]Account `json:"accounts,omitempty"`
		Login    *Login     `json:"login,omitempty"`
		Token    *string    `json:"token,omitempty"`
		Users    *[]User    `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
		// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
		// first up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

		// Shiftchains Any shift chains that the fetched shifts are a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		Shifts      *[]Shift      `json:"shifts,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Shifts Array of shift objects to update
		Shifts *[]Shift `json:"shifts,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r BulkUpdateShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEligibleUsersForOpenShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Users *[]User `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListEligibleUsersForOpenShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEligibleUsersForOpenShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Email A count of the emails sent.
		Email *int `json:"email,omitempty"`

		// Sms A count of the SMS and/or push notifications (depending on user preferences) sent.
		Sms     *int  `json:"sms,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r NotifyShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifySingleShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Email A count of the emails sent.
		Email *int `json:"email,omitempty"`

		// Sms A count of the SMS and/or push notifications (depending on user preferences) sent.
		Sms     *int  `json:"sms,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r NotifySingleShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifySingleShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Shifts *[]Shift `json:"shifts,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PublishShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Shifts *[]Shift `json:"shifts,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UnassignShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpublishShiftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Shifts *[]Shift `json:"shifts,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UnpublishShiftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpublishShiftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted The IDs of the shifts that were deleted
		Deleted *[]int `json:"deleted,omitempty"`

		// Success Whether deletion was successful. If absent, it means nothing was actually deleted.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. If the fetched shift has a shift chain, we will insert all the shifts on that chain from the first up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
		Shift           *Shift   `json:"shift,omitempty"`

		// Shiftchains Any shift chain this shift is a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUsersToOpenShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Openshiftapprovalrequests *[]OpenShiftApprovalRequest `json:"openshiftapprovalrequests,omitempty"`
		Shifts                    *[]Shift                    `json:"shifts,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AssignUsersToOpenShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUsersToOpenShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShiftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted A list of shift IDs that were deleted as a result of the update. Applicable for updates to repeating shifts that impact future shifts on the same chain.
		Deleted *[]int `json:"deleted,omitempty"`

		// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. We will insert the created or edited shifts from the beginning of the chain up to the date specified in the parameter.
		RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
		Shift           *Shift   `json:"shift,omitempty"`

		// Shiftchains Any shift chain this shift is a part of
		Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateShiftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShiftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// History Array of history events
		History *[]ShiftHistory `json:"history,omitempty"`
		Shift   *Shift          `json:"shift,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetShiftHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CanRelease Indicates if this shift can be released
		CanRelease *bool `json:"can_release,omitempty"`

		// Count A count of all the eligible takers
		Count *int                    `json:"count,omitempty"`
		Users *GetSwapUsers_200_Users `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}
type GetSwapUsers200Users0 = []User
type GetSwapUsers200Users1 = []string
type GetSwapUsers_200_Users struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetSwapUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Sites *[]Site `json:"sites,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether deletion was successful.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Site *Site `json:"site,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Times *[]Time `json:"times,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListTimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether deletion was successful.
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Time *Time `json:"time,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Users *[]User `json:"users,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User *User `json:"user,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateUserAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User *User `json:"user,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateUserAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateUserAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkUserResponse
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r BulkCreateUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InviteUserResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InviteUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteSingleUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InviteUserResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InviteSingleUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteSingleUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Success *bool `json:"success,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User *User `json:"user,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User *User `json:"user,omitempty"`
	}
	JSON404     *Error
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ListShiftsWithResponse request returning *ListShiftsResponse
func (c *ClientWithResponses) ListShiftsWithResponse(ctx context.Context, params *ListShiftsParams, reqEditors ...RequestEditorFn) (*ListShiftsResponse, error) {
	rsp, err := c.ListShifts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListShiftsResponse(rsp)
}

// BulkUpdateShiftsWithBodyWithResponse request with arbitrary body returning *BulkUpdateShiftsResponse
func (c *ClientWithResponses) BulkUpdateShiftsWithBodyWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error) {
	rsp, err := c.BulkUpdateShiftsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateShiftsResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateShiftsWithResponse(ctx context.Context, params *BulkUpdateShiftsParams, body BulkUpdateShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateShiftsResponse, error) {
	rsp, err := c.BulkUpdateShifts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateShiftsResponse(rsp)
}

// ListEligibleUsersForOpenShiftWithResponse request returning *ListEligibleUsersForOpenShiftResponse
func (c *ClientWithResponses) ListEligibleUsersForOpenShiftWithResponse(ctx context.Context, params *ListEligibleUsersForOpenShiftParams, reqEditors ...RequestEditorFn) (*ListEligibleUsersForOpenShiftResponse, error) {
	rsp, err := c.ListEligibleUsersForOpenShift(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEligibleUsersForOpenShiftResponse(rsp)
}

// NotifyShiftsWithBodyWithResponse request with arbitrary body returning *NotifyShiftsResponse
func (c *ClientWithResponses) NotifyShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifyShiftsResponse, error) {
	rsp, err := c.NotifyShiftsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyShiftsResponse(rsp)
}

func (c *ClientWithResponses) NotifyShiftsWithResponse(ctx context.Context, body NotifyShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifyShiftsResponse, error) {
	rsp, err := c.NotifyShifts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyShiftsResponse(rsp)
}

// NotifySingleShiftWithBodyWithResponse request with arbitrary body returning *NotifySingleShiftResponse
func (c *ClientWithResponses) NotifySingleShiftWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotifySingleShiftResponse, error) {
	rsp, err := c.NotifySingleShiftWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifySingleShiftResponse(rsp)
}

func (c *ClientWithResponses) NotifySingleShiftWithResponse(ctx context.Context, id int, body NotifySingleShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*NotifySingleShiftResponse, error) {
	rsp, err := c.NotifySingleShift(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifySingleShiftResponse(rsp)
}

// PublishShiftsWithBodyWithResponse request with arbitrary body returning *PublishShiftsResponse
func (c *ClientWithResponses) PublishShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishShiftsResponse, error) {
	rsp, err := c.PublishShiftsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishShiftsResponse(rsp)
}

func (c *ClientWithResponses) PublishShiftsWithResponse(ctx context.Context, body PublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishShiftsResponse, error) {
	rsp, err := c.PublishShifts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishShiftsResponse(rsp)
}

// UnassignShiftsWithBodyWithResponse request with arbitrary body returning *UnassignShiftsResponse
func (c *ClientWithResponses) UnassignShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnassignShiftsResponse, error) {
	rsp, err := c.UnassignShiftsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignShiftsResponse(rsp)
}

func (c *ClientWithResponses) UnassignShiftsWithResponse(ctx context.Context, body UnassignShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnassignShiftsResponse, error) {
	rsp, err := c.UnassignShifts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignShiftsResponse(rsp)
}

// UnpublishShiftsWithBodyWithResponse request with arbitrary body returning *UnpublishShiftsResponse
func (c *ClientWithResponses) UnpublishShiftsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnpublishShiftsResponse, error) {
	rsp, err := c.UnpublishShiftsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishShiftsResponse(rsp)
}

func (c *ClientWithResponses) UnpublishShiftsWithResponse(ctx context.Context, body UnpublishShiftsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnpublishShiftsResponse, error) {
	rsp, err := c.UnpublishShifts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishShiftsResponse(rsp)
}

// DeleteShiftWithResponse request returning *DeleteShiftResponse
func (c *ClientWithResponses) DeleteShiftWithResponse(ctx context.Context, id int, params *DeleteShiftParams, reqEditors ...RequestEditorFn) (*DeleteShiftResponse, error) {
	rsp, err := c.DeleteShift(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShiftResponse(rsp)
}

// GetShiftWithResponse request returning *GetShiftResponse
func (c *ClientWithResponses) GetShiftWithResponse(ctx context.Context, id int, params *GetShiftParams, reqEditors ...RequestEditorFn) (*GetShiftResponse, error) {
	rsp, err := c.GetShift(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftResponse(rsp)
}

// AssignUsersToOpenShiftWithBodyWithResponse request with arbitrary body returning *AssignUsersToOpenShiftResponse
func (c *ClientWithResponses) AssignUsersToOpenShiftWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUsersToOpenShiftResponse, error) {
	rsp, err := c.AssignUsersToOpenShiftWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUsersToOpenShiftResponse(rsp)
}

func (c *ClientWithResponses) AssignUsersToOpenShiftWithResponse(ctx context.Context, id int, body AssignUsersToOpenShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUsersToOpenShiftResponse, error) {
	rsp, err := c.AssignUsersToOpenShift(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUsersToOpenShiftResponse(rsp)
}

// UpdateShiftWithBodyWithResponse request with arbitrary body returning *UpdateShiftResponse
func (c *ClientWithResponses) UpdateShiftWithBodyWithResponse(ctx context.Context, id int, params *UpdateShiftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error) {
	rsp, err := c.UpdateShiftWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShiftResponse(rsp)
}

func (c *ClientWithResponses) UpdateShiftWithResponse(ctx context.Context, id int, params *UpdateShiftParams, body UpdateShiftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShiftResponse, error) {
	rsp, err := c.UpdateShift(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShiftResponse(rsp)
}

// GetShiftHistoryWithResponse request returning *GetShiftHistoryResponse
func (c *ClientWithResponses) GetShiftHistoryWithResponse(ctx context.Context, id int, params *GetShiftHistoryParams, reqEditors ...RequestEditorFn) (*GetShiftHistoryResponse, error) {
	rsp, err := c.GetShiftHistory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftHistoryResponse(rsp)
}

// GetSwapUsersWithResponse request returning *GetSwapUsersResponse
func (c *ClientWithResponses) GetSwapUsersWithResponse(ctx context.Context, id int, params *GetSwapUsersParams, reqEditors ...RequestEditorFn) (*GetSwapUsersResponse, error) {
	rsp, err := c.GetSwapUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapUsersResponse(rsp)
}

// ListSitesWithResponse request returning *ListSitesResponse
func (c *ClientWithResponses) ListSitesWithResponse(ctx context.Context, params *ListSitesParams, reqEditors ...RequestEditorFn) (*ListSitesResponse, error) {
	rsp, err := c.ListSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSitesResponse(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResponse
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSiteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

// DeleteSiteWithResponse request returning *DeleteSiteResponse
func (c *ClientWithResponses) DeleteSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error) {
	rsp, err := c.DeleteSite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteResponse(rsp)
}

// GetSiteWithResponse request returning *GetSiteResponse
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSiteResponse, error) {
	rsp, err := c.GetSite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResponse(rsp)
}

// UpdateSiteWithBodyWithResponse request with arbitrary body returning *UpdateSiteResponse
func (c *ClientWithResponses) UpdateSiteWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error) {
	rsp, err := c.UpdateSiteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSiteResponse(rsp)
}

func (c *ClientWithResponses) UpdateSiteWithResponse(ctx context.Context, id int, body UpdateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSiteResponse, error) {
	rsp, err := c.UpdateSite(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSiteResponse(rsp)
}

// ListTimesWithResponse request returning *ListTimesResponse
func (c *ClientWithResponses) ListTimesWithResponse(ctx context.Context, params *ListTimesParams, reqEditors ...RequestEditorFn) (*ListTimesResponse, error) {
	rsp, err := c.ListTimes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTimesResponse(rsp)
}

// CreateTimeWithBodyWithResponse request with arbitrary body returning *CreateTimeResponse
func (c *ClientWithResponses) CreateTimeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error) {
	rsp, err := c.CreateTimeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimeResponse(rsp)
}

func (c *ClientWithResponses) CreateTimeWithResponse(ctx context.Context, body CreateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimeResponse, error) {
	rsp, err := c.CreateTime(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimeResponse(rsp)
}

// DeleteTimeWithResponse request returning *DeleteTimeResponse
func (c *ClientWithResponses) DeleteTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTimeResponse, error) {
	rsp, err := c.DeleteTime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTimeResponse(rsp)
}

// GetTimeWithResponse request returning *GetTimeResponse
func (c *ClientWithResponses) GetTimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTimeResponse, error) {
	rsp, err := c.GetTime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeResponse(rsp)
}

// UpdateTimeWithBodyWithResponse request with arbitrary body returning *UpdateTimeResponse
func (c *ClientWithResponses) UpdateTimeWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error) {
	rsp, err := c.UpdateTimeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimeResponse(rsp)
}

func (c *ClientWithResponses) UpdateTimeWithResponse(ctx context.Context, id int, body UpdateTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimeResponse, error) {
	rsp, err := c.UpdateTime(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimeResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// CreateOrUpdateUserAvatarWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateUserAvatarResponse
func (c *ClientWithResponses) CreateOrUpdateUserAvatarWithBodyWithResponse(ctx context.Context, id int, params *CreateOrUpdateUserAvatarParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateUserAvatarResponse, error) {
	rsp, err := c.CreateOrUpdateUserAvatarWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateUserAvatarResponse(rsp)
}

// BulkCreateUsersWithBodyWithResponse request with arbitrary body returning *BulkCreateUsersResponse
func (c *ClientWithResponses) BulkCreateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error) {
	rsp, err := c.BulkCreateUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateUsersResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateUsersWithResponse(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error) {
	rsp, err := c.BulkCreateUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateUsersResponse(rsp)
}

// InviteUsersWithBodyWithResponse request with arbitrary body returning *InviteUsersResponse
func (c *ClientWithResponses) InviteUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersResponse, error) {
	rsp, err := c.InviteUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersResponse(rsp)
}

func (c *ClientWithResponses) InviteUsersWithResponse(ctx context.Context, body InviteUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersResponse, error) {
	rsp, err := c.InviteUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersResponse(rsp)
}

// InviteSingleUserWithBodyWithResponse request with arbitrary body returning *InviteSingleUserResponse
func (c *ClientWithResponses) InviteSingleUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteSingleUserResponse, error) {
	rsp, err := c.InviteSingleUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteSingleUserResponse(rsp)
}

func (c *ClientWithResponses) InviteSingleUserWithResponse(ctx context.Context, id int, body InviteSingleUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteSingleUserResponse, error) {
	rsp, err := c.InviteSingleUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteSingleUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, id int, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts *[]Account `json:"accounts,omitempty"`
			Login    *Login     `json:"login,omitempty"`
			Token    *string    `json:"token,omitempty"`
			Users    *[]User    `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListShiftsResponse parses an HTTP response from a ListShiftsWithResponse call
func ParseListShiftsResponse(rsp *http.Response) (*ListShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. For each
			// fetched shift, if it is on a shift chain, we will insert all the shifts on that chain from the
			// first up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`

			// Shiftchains Any shift chains that the fetched shifts are a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
			Shifts      *[]Shift      `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBulkUpdateShiftsResponse parses an HTTP response from a BulkUpdateShiftsWithResponse call
func ParseBulkUpdateShiftsResponse(rsp *http.Response) (*BulkUpdateShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Shifts Array of shift objects to update
			Shifts *[]Shift `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListEligibleUsersForOpenShiftResponse parses an HTTP response from a ListEligibleUsersForOpenShiftWithResponse call
func ParseListEligibleUsersForOpenShiftResponse(rsp *http.Response) (*ListEligibleUsersForOpenShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEligibleUsersForOpenShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Users *[]User `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseNotifyShiftsResponse parses an HTTP response from a NotifyShiftsWithResponse call
func ParseNotifyShiftsResponse(rsp *http.Response) (*NotifyShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Email A count of the emails sent.
			Email *int `json:"email,omitempty"`

			// Sms A count of the SMS and/or push notifications (depending on user preferences) sent.
			Sms     *int  `json:"sms,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseNotifySingleShiftResponse parses an HTTP response from a NotifySingleShiftWithResponse call
func ParseNotifySingleShiftResponse(rsp *http.Response) (*NotifySingleShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifySingleShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Email A count of the emails sent.
			Email *int `json:"email,omitempty"`

			// Sms A count of the SMS and/or push notifications (depending on user preferences) sent.
			Sms     *int  `json:"sms,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePublishShiftsResponse parses an HTTP response from a PublishShiftsWithResponse call
func ParsePublishShiftsResponse(rsp *http.Response) (*PublishShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Shifts *[]Shift `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignShiftsResponse parses an HTTP response from a UnassignShiftsWithResponse call
func ParseUnassignShiftsResponse(rsp *http.Response) (*UnassignShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Shifts *[]Shift `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnpublishShiftsResponse parses an HTTP response from a UnpublishShiftsWithResponse call
func ParseUnpublishShiftsResponse(rsp *http.Response) (*UnpublishShiftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpublishShiftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Shifts *[]Shift `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteShiftResponse parses an HTTP response from a DeleteShiftWithResponse call
func ParseDeleteShiftResponse(rsp *http.Response) (*DeleteShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted The IDs of the shifts that were deleted
			Deleted *[]int `json:"deleted,omitempty"`

			// Success Whether deletion was successful. If absent, it means nothing was actually deleted.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetShiftResponse parses an HTTP response from a GetShiftWithResponse call
func ParseGetShiftResponse(rsp *http.Response) (*GetShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. If the fetched shift has a shift chain, we will insert all the shifts on that chain from the first up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
			Shift           *Shift   `json:"shift,omitempty"`

			// Shiftchains Any shift chain this shift is a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignUsersToOpenShiftResponse parses an HTTP response from a AssignUsersToOpenShiftWithResponse call
func ParseAssignUsersToOpenShiftResponse(rsp *http.Response) (*AssignUsersToOpenShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUsersToOpenShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Openshiftapprovalrequests *[]OpenShiftApprovalRequest `json:"openshiftapprovalrequests,omitempty"`
			Shifts                    *[]Shift                    `json:"shifts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateShiftResponse parses an HTTP response from a UpdateShiftWithResponse call
func ParseUpdateShiftResponse(rsp *http.Response) (*UpdateShiftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShiftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted A list of shift IDs that were deleted as a result of the update. Applicable for updates to repeating shifts that impact future shifts on the same chain.
			Deleted *[]int `json:"deleted,omitempty"`

			// RepeatingShifts This field will be present if the `include_repeating_shifts_to` parameter is provided. We will insert the created or edited shifts from the beginning of the chain up to the date specified in the parameter.
			RepeatingShifts *[]Shift `json:"repeating_shifts,omitempty"`
			Shift           *Shift   `json:"shift,omitempty"`

			// Shiftchains Any shift chain this shift is a part of
			Shiftchains *[]ShiftChain `json:"shiftchains,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetShiftHistoryResponse parses an HTTP response from a GetShiftHistoryWithResponse call
func ParseGetShiftHistoryResponse(rsp *http.Response) (*GetShiftHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// History Array of history events
			History *[]ShiftHistory `json:"history,omitempty"`
			Shift   *Shift          `json:"shift,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSwapUsersResponse parses an HTTP response from a GetSwapUsersWithResponse call
func ParseGetSwapUsersResponse(rsp *http.Response) (*GetSwapUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CanRelease Indicates if this shift can be released
			CanRelease *bool `json:"can_release,omitempty"`

			// Count A count of all the eligible takers
			Count *int                    `json:"count,omitempty"`
			Users *GetSwapUsers_200_Users `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListSitesResponse parses an HTTP response from a ListSitesWithResponse call
func ParseListSitesResponse(rsp *http.Response) (*ListSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Sites *[]Site `json:"sites,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSiteResponse parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResponse(rsp *http.Response) (*CreateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSiteResponse parses an HTTP response from a DeleteSiteWithResponse call
func ParseDeleteSiteResponse(rsp *http.Response) (*DeleteSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether deletion was successful.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSiteResponse parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResponse(rsp *http.Response) (*GetSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSiteResponse parses an HTTP response from a UpdateSiteWithResponse call
func ParseUpdateSiteResponse(rsp *http.Response) (*UpdateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Site *Site `json:"site,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTimesResponse parses an HTTP response from a ListTimesWithResponse call
func ParseListTimesResponse(rsp *http.Response) (*ListTimesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Times *[]Time `json:"times,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTimeResponse parses an HTTP response from a CreateTimeWithResponse call
func ParseCreateTimeResponse(rsp *http.Response) (*CreateTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTimeResponse parses an HTTP response from a DeleteTimeWithResponse call
func ParseDeleteTimeResponse(rsp *http.Response) (*DeleteTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether deletion was successful.
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTimeResponse parses an HTTP response from a GetTimeWithResponse call
func ParseGetTimeResponse(rsp *http.Response) (*GetTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTimeResponse parses an HTTP response from a UpdateTimeWithResponse call
func ParseUpdateTimeResponse(rsp *http.Response) (*UpdateTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Time *Time `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Users *[]User `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User *User `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateUserAvatarResponse parses an HTTP response from a CreateOrUpdateUserAvatarWithResponse call
func ParseCreateOrUpdateUserAvatarResponse(rsp *http.Response) (*CreateOrUpdateUserAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateUserAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User *User `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBulkCreateUsersResponse parses an HTTP response from a BulkCreateUsersWithResponse call
func ParseBulkCreateUsersResponse(rsp *http.Response) (*BulkCreateUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInviteUsersResponse parses an HTTP response from a InviteUsersWithResponse call
func ParseInviteUsersResponse(rsp *http.Response) (*InviteUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InviteUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInviteSingleUserResponse parses an HTTP response from a InviteSingleUserWithResponse call
func ParseInviteSingleUserResponse(rsp *http.Response) (*InviteSingleUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteSingleUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InviteUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User *User `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User *User `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
